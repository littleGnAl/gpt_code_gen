/// GENERATED BY gpt_code_gen, DO NOT MODIFY BY HAND.
class IRtcEngineWrapper {
protected:
  IRtcEngine *wrapper_;

public:
int release(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool sync = false;
    if (!reader["sync"].is_null()) sync = reader["sync"];

    MyJson outdata;
    wrapper_->release(sync);
    outdata["result"] = 0;
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int initialize(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    RtcEngineContext context;

    MyJson logConfigReader = reader["logConfig"];
    MyJson threadPriorityReader = reader["threadPriority"];

    if (!reader["appId"].is_null()) context.appId = reader["appId"];
    if (!reader["context"].is_null()) context.context = (void *)(long) reader["context"];
    if (!reader["channelProfile"].is_null()) context.channelProfile = reader["channelProfile"];
    if (!reader["license"].is_null()) context.license = reader["license"];
    if (!reader["audioScenario"].is_null()) context.audioScenario = reader["audioScenario"];
    if (!reader["areaCode"].is_null()) context.areaCode = reader["areaCode"];
    if (!logConfigReader.is_null()) {
        if (!logConfigReader["filePath"].is_null()) context.logConfig.filePath = logConfigReader["filePath"];
        if (!logConfigReader["fileSize"].is_null()) context.logConfig.fileSize = logConfigReader["fileSize"];
        if (!logConfigReader["level"].is_null()) context.logConfig.level = logConfigReader["level"];
    }
    if (!threadPriorityReader.is_null()) context.threadPriority = threadPriorityReader;
    if (!reader["useExternalEglContext"].is_null()) context.useExternalEglContext = reader["useExternalEglContext"];
    if (!reader["domainLimit"].is_null()) context.domainLimit = reader["domainLimit"];

    MyJson outdata;
    outdata["result"] = wrapper_->initialize(context);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int queryInterface(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    INTERFACE_ID_TYPE iid = AGORA_IID_AUDIO_DEVICE_MANAGER;
    if (!reader["iid"].is_null()) iid = reader["iid"];

    void* inter = nullptr;
    MyJson outdata;
    outdata["result"] = wrapper_->queryInterface(iid, &inter);
    outdata["inter"] = (long) inter;

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getVersion(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int build = 0;
    const char *version = wrapper_->getVersion(&build);

    MyJson outdata;
    outdata["result"]["version"] = version;
    outdata["result"]["build"] = build;

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getErrorDescription(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int code = 0;
    if (!reader["code"].is_null()) code = reader["code"];

    MyJson outdata;
    outdata["result"] = wrapper_->getErrorDescription(code);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int joinChannel(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string token = "";
    string channelId = "";
    string info = "";
    uid_t uid;
    if (!reader["token"].is_null()) token = reader["token"];
    if (!reader["channelId"].is_null()) channelId = reader["channelId"];
    if (!reader["info"].is_null()) info = reader["info"];
    if (!reader["uid"].is_null()) uid = (uid_t)(long) reader["uid"];

    MyJson outdata;
    outdata["result"] = wrapper_->joinChannel(
        token.empty() ? nullptr : token.c_str(), channelId.c_str(),
        info.empty() ? nullptr : info.c_str(), uid);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int joinChannel(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string token = "";
    string channelId = "";
    uid_t uid;
    ChannelMediaOptions options;

    if (!reader["token"].is_null()) token = reader["token"];
    if (!reader["channelId"].is_null()) channelId = reader["channelId"];
    if (!reader["uid"].is_null()) uid = (uid_t)(long) reader["uid"];

    MyJson optionsReader = reader["options"];

    if (!optionsReader["publishCameraTrack"].is_null())
        options.publishCameraTrack = optionsReader["publishCameraTrack"];
    if (!optionsReader["publishSecondaryCameraTrack"].is_null())
        options.publishSecondaryCameraTrack = optionsReader["publishSecondaryCameraTrack"];
    if (!optionsReader["publishMicrophoneTrack"].is_null())
        options.publishMicrophoneTrack = optionsReader["publishMicrophoneTrack"];
#if defined(__ANDROID__) || (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE)
    if (!optionsReader["publishScreenCaptureVideo"].is_null())
        options.publishScreenCaptureVideo = optionsReader["publishScreenCaptureVideo"];
    if (!optionsReader["publishScreenCaptureAudio"].is_null())
        options.publishScreenCaptureAudio = optionsReader["publishScreenCaptureAudio"];
#else
    if (!optionsReader["publishScreenTrack"].is_null())
        options.publishScreenTrack = optionsReader["publishScreenTrack"];
    if (!optionsReader["publishSecondaryScreenTrack"].is_null())
        options.publishSecondaryScreenTrack = optionsReader["publishSecondaryScreenTrack"];
#endif
    if (!optionsReader["publishCustomAudioTrack"].is_null())
        options.publishCustomAudioTrack = optionsReader["publishCustomAudioTrack"];
    if (!optionsReader["publishCustomAudioSourceId"].is_null())
        options.publishCustomAudioSourceId = optionsReader["publishCustomAudioSourceId"];
    if (!optionsReader["publishCustomAudioTrackEnableAec"].is_null())
        options.publishCustomAudioTrackEnableAec = optionsReader["publishCustomAudioTrackEnableAec"];
    if (!optionsReader["publishDirectCustomAudioTrack"].is_null())
        options.publishDirectCustomAudioTrack = optionsReader["publishDirectCustomAudioTrack"];
    if (!optionsReader["publishCustomAudioTrackAec"].is_null())
        options.publishCustomAudioTrackAec = optionsReader["publishCustomAudioTrackAec"];
    if (!optionsReader["publishCustomVideoTrack"].is_null())
        options.publishCustomVideoTrack = optionsReader["publishCustomVideoTrack"];
    if (!optionsReader["publishEncodedVideoTrack"].is_null())
        options.publishEncodedVideoTrack = optionsReader["publishEncodedVideoTrack"];
    if (!optionsReader["publishMediaPlayerAudioTrack"].is_null())
        options.publishMediaPlayerAudioTrack = optionsReader["publishMediaPlayerAudioTrack"];
    if (!optionsReader["publishMediaPlayerVideoTrack"].is_null())
        options.publishMediaPlayerVideoTrack = optionsReader["publishMediaPlayerVideoTrack"];
    if (!optionsReader["publishTrancodedVideoTrack"].is_null())
        options.publishTrancodedVideoTrack = optionsReader["publishTrancodedVideoTrack"];
    if (!optionsReader["autoSubscribeAudio"].is_null())
        options.autoSubscribeAudio = optionsReader["autoSubscribeAudio"];
    if (!optionsReader["autoSubscribeVideo"].is_null())
        options.autoSubscribeVideo = optionsReader["autoSubscribeVideo"];
    if (!optionsReader["enableAudioRecordingOrPlayout"].is_null())
        options.enableAudioRecordingOrPlayout = optionsReader["enableAudioRecordingOrPlayout"];
    if (!optionsReader["publishMediaPlayerId"].is_null())
        options.publishMediaPlayerId = optionsReader["publishMediaPlayerId"];
    if (!optionsReader["clientRoleType"].is_null())
        options.clientRoleType = optionsReader["clientRoleType"];
    if (!optionsReader["audienceLatencyLevel"].is_null())
        options.audienceLatencyLevel = optionsReader["audienceLatencyLevel"];
    if (!optionsReader["defaultVideoStreamType"].is_null())
        options.defaultVideoStreamType = optionsReader["defaultVideoStreamType"];
    if (!optionsReader["channelProfile"].is_null())
        options.channelProfile = optionsReader["channelProfile"];
    if (!optionsReader["audioDelayMs"].is_null())
        options.audioDelayMs = optionsReader["audioDelayMs"];
    if (!optionsReader["mediaPlayerAudioDelayMs"].is_null())
        options.mediaPlayerAudioDelayMs = optionsReader["mediaPlayerAudioDelayMs"];
    if (!optionsReader["enableBuiltInMediaEncryption"].is_null())
        options.enableBuiltInMediaEncryption = optionsReader["enableBuiltInMediaEncryption"];
    if (!optionsReader["publishRhythmPlayerTrack"].is_null())
        options.publishRhythmPlayerTrack = optionsReader["publishRhythmPlayerTrack"];
    if (!optionsReader["isInteractiveAudience"].is_null())
        options.isInteractiveAudience = optionsReader["isInteractiveAudience"];
    if (!optionsReader["customVideoTrackId"].is_null())
        options.customVideoTrackId = optionsReader["customVideoTrackId"];
    if (!optionsReader["isAudioFilterable"].is_null())
        options.isAudioFilterable = optionsReader["isAudioFilterable"];

    MyJson outdata;
    outdata["result"] = wrapper_->joinChannel(
        token.empty() ? nullptr : token.c_str(), channelId.c_str(), uid, options);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int updateChannelMediaOptions(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    ChannelMediaOptions options;

    MyJson channelMediaOptionsReader = reader["options"];

    if (!channelMediaOptionsReader["publishCameraTrack"].is_null())
        options.publishCameraTrack = channelMediaOptionsReader["publishCameraTrack"];
    if (!channelMediaOptionsReader["publishSecondaryCameraTrack"].is_null())
        options.publishSecondaryCameraTrack = channelMediaOptionsReader["publishSecondaryCameraTrack"];
    if (!channelMediaOptionsReader["publishMicrophoneTrack"].is_null())
        options.publishMicrophoneTrack = channelMediaOptionsReader["publishMicrophoneTrack"];
#if defined(__ANDROID__) || (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE)
    if (!channelMediaOptionsReader["publishScreenCaptureVideo"].is_null())
        options.publishScreenCaptureVideo = channelMediaOptionsReader["publishScreenCaptureVideo"];
    if (!channelMediaOptionsReader["publishScreenCaptureAudio"].is_null())
        options.publishScreenCaptureAudio = channelMediaOptionsReader["publishScreenCaptureAudio"];
#else
    if (!channelMediaOptionsReader["publishScreenTrack"].is_null())
        options.publishScreenTrack = channelMediaOptionsReader["publishScreenTrack"];
    if (!channelMediaOptionsReader["publishSecondaryScreenTrack"].is_null())
        options.publishSecondaryScreenTrack = channelMediaOptionsReader["publishSecondaryScreenTrack"];
#endif
    if (!channelMediaOptionsReader["publishCustomAudioTrack"].is_null())
        options.publishCustomAudioTrack = channelMediaOptionsReader["publishCustomAudioTrack"];
    if (!channelMediaOptionsReader["publishCustomAudioSourceId"].is_null())
        options.publishCustomAudioSourceId = channelMediaOptionsReader["publishCustomAudioSourceId"];
    if (!channelMediaOptionsReader["publishCustomAudioTrackEnableAec"].is_null())
        options.publishCustomAudioTrackEnableAec = channelMediaOptionsReader["publishCustomAudioTrackEnableAec"];
    if (!channelMediaOptionsReader["publishDirectCustomAudioTrack"].is_null())
        options.publishDirectCustomAudioTrack = channelMediaOptionsReader["publishDirectCustomAudioTrack"];
    if (!channelMediaOptionsReader["publishCustomAudioTrackAec"].is_null())
        options.publishCustomAudioTrackAec = channelMediaOptionsReader["publishCustomAudioTrackAec"];
    if (!channelMediaOptionsReader["publishCustomVideoTrack"].is_null())
        options.publishCustomVideoTrack = channelMediaOptionsReader["publishCustomVideoTrack"];
    if (!channelMediaOptionsReader["publishEncodedVideoTrack"].is_null())
        options.publishEncodedVideoTrack = channelMediaOptionsReader["publishEncodedVideoTrack"];
    if (!channelMediaOptionsReader["publishMediaPlayerAudioTrack"].is_null())
        options.publishMediaPlayerAudioTrack = channelMediaOptionsReader["publishMediaPlayerAudioTrack"];
    if (!channelMediaOptionsReader["publishMediaPlayerVideoTrack"].is_null())
        options.publishMediaPlayerVideoTrack = channelMediaOptionsReader["publishMediaPlayerVideoTrack"];
    if (!channelMediaOptionsReader["publishTrancodedVideoTrack"].is_null())
        options.publishTrancodedVideoTrack = channelMediaOptionsReader["publishTrancodedVideoTrack"];
    if (!channelMediaOptionsReader["autoSubscribeAudio"].is_null())
        options.autoSubscribeAudio = channelMediaOptionsReader["autoSubscribeAudio"];
    if (!channelMediaOptionsReader["autoSubscribeVideo"].is_null())
        options.autoSubscribeVideo = channelMediaOptionsReader["autoSubscribeVideo"];
    if (!channelMediaOptionsReader["enableAudioRecordingOrPlayout"].is_null())
        options.enableAudioRecordingOrPlayout = channelMediaOptionsReader["enableAudioRecordingOrPlayout"];
    if (!channelMediaOptionsReader["publishMediaPlayerId"].is_null())
        options.publishMediaPlayerId = channelMediaOptionsReader["publishMediaPlayerId"];
    if (!channelMediaOptionsReader["clientRoleType"].is_null())
        options.clientRoleType = channelMediaOptionsReader["clientRoleType"];
    if (!channelMediaOptionsReader["audienceLatencyLevel"].is_null())
        options.audienceLatencyLevel = channelMediaOptionsReader["audienceLatencyLevel"];
    if (!channelMediaOptionsReader["defaultVideoStreamType"].is_null())
        options.defaultVideoStreamType = channelMediaOptionsReader["defaultVideoStreamType"];
    if (!channelMediaOptionsReader["channelProfile"].is_null())
        options.channelProfile = channelMediaOptionsReader["channelProfile"];
    if (!channelMediaOptionsReader["audioDelayMs"].is_null())
        options.audioDelayMs = channelMediaOptionsReader["audioDelayMs"];
    if (!channelMediaOptionsReader["mediaPlayerAudioDelayMs"].is_null())
        options.mediaPlayerAudioDelayMs = channelMediaOptionsReader["mediaPlayerAudioDelayMs"];
    if (!channelMediaOptionsReader["token"].is_null())
        options.token = channelMediaOptionsReader["token"];
    if (!channelMediaOptionsReader["enableBuiltInMediaEncryption"].is_null())
        options.enableBuiltInMediaEncryption = channelMediaOptionsReader["enableBuiltInMediaEncryption"];
    if (!channelMediaOptionsReader["publishRhythmPlayerTrack"].is_null())
        options.publishRhythmPlayerTrack = channelMediaOptionsReader["publishRhythmPlayerTrack"];
    if (!channelMediaOptionsReader["isInteractiveAudience"].is_null())
        options.isInteractiveAudience = channelMediaOptionsReader["isInteractiveAudience"];
    if (!channelMediaOptionsReader["customVideoTrackId"].is_null())
        options.customVideoTrackId = channelMediaOptionsReader["customVideoTrackId"];
    if (!channelMediaOptionsReader["isAudioFilterable"].is_null())
        options.isAudioFilterable = channelMediaOptionsReader["isAudioFilterable"];

    MyJson outdata;
    outdata["result"] = wrapper_->updateChannelMediaOptions(options);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int leaveChannel(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->leaveChannel();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int leaveChannel(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    LeaveChannelOptions options;

    MyJson leaveChannelOptionsReader = reader["options"];

    if (!leaveChannelOptionsReader["stopAudioMixing"].is_null())
        options.stopAudioMixing = leaveChannelOptionsReader["stopAudioMixing"];
    if (!leaveChannelOptionsReader["stopAllEffect"].is_null())
        options.stopAllEffect = leaveChannelOptionsReader["stopAllEffect"];
    if (!leaveChannelOptionsReader["stopMicrophoneRecording"].is_null())
        options.stopMicrophoneRecording = leaveChannelOptionsReader["stopMicrophoneRecording"];

    MyJson outdata;
    outdata["result"] = wrapper_->leaveChannel(options);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int renewToken(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string token = "";
    if (!reader["token"].is_null()) token = reader["token"];

    MyJson outdata;
    outdata["result"] = wrapper_->renewToken(token.empty() ? nullptr : token.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setChannelProfile(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    CHANNEL_PROFILE_TYPE profile = CHANNEL_PROFILE_COMMUNICATION;
    if (!reader["profile"].is_null()) profile = reader["profile"];

    MyJson outdata;
    outdata["result"] = wrapper_->setChannelProfile(profile);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setClientRole(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    CLIENT_ROLE_TYPE role = CLIENT_ROLE_AUDIENCE;
    if (!reader["role"].is_null()) role = reader["role"];

    MyJson outdata;
    outdata["result"] = wrapper_->setClientRole(role);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setClientRole(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    CLIENT_ROLE_TYPE role = CLIENT_ROLE_AUDIENCE;
    if (!reader["role"].is_null()) role = reader["role"];

    ClientRoleOptions options;
    MyJson optionsReader = reader["options"];
    if (!optionsReader.is_null()) {
        if (!optionsReader["audienceLatencyLevel"].is_null())
            options.audienceLatencyLevel = (AUDIENCE_LATENCY_LEVEL_TYPE)optionsReader["audienceLatencyLevel"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->setClientRole(role, options);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startEchoTest(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->startEchoTest();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startEchoTest(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int intervalInSeconds = 0;
    if (!reader["intervalInSeconds"].is_null()) intervalInSeconds = reader["intervalInSeconds"];

    MyJson outdata;
    outdata["result"] = wrapper_->startEchoTest(intervalInSeconds);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startEchoTest(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    EchoTestConfiguration config;

    MyJson echoTestConfigReader = reader["config"];

    if (!echoTestConfigReader["view"].is_null())
        config.view = (view_t)(long) echoTestConfigReader["view"];
    if (!echoTestConfigReader["enableAudio"].is_null())
        config.enableAudio = echoTestConfigReader["enableAudio"];
    if (!echoTestConfigReader["enableVideo"].is_null())
        config.enableVideo = echoTestConfigReader["enableVideo"];
    if (!echoTestConfigReader["token"].is_null())
        config.token = echoTestConfigReader["token"];
    if (!echoTestConfigReader["channelId"].is_null())
        config.channelId = echoTestConfigReader["channelId"];

    MyJson outdata;
    outdata["result"] = wrapper_->startEchoTest(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopEchoTest(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopEchoTest();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableMultiCamera(const char *buff, size_t bufflen, std::string &out) {
#if defined(__APPLE__) && TARGET_OS_IOS
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    CameraCapturerConfiguration config;

    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson cameraCapturerConfigReader = reader["config"];

#if defined(__ANDROID__) || (defined(__APPLE__) && TARGET_OS_IOS)
    if (!cameraCapturerConfigReader["cameraDirection"].is_null())
        config.cameraDirection = (CAMERA_DIRECTION)cameraCapturerConfigReader["cameraDirection"];
#else
    if (!cameraCapturerConfigReader["deviceId"].is_null())
        strncpy(config.deviceId, cameraCapturerConfigReader["deviceId"].get<std::string>().c_str(), MAX_DEVICE_ID_LENGTH);
#endif

    if (!cameraCapturerConfigReader["format"].is_null()) {
        MyJson formatReader = cameraCapturerConfigReader["format"];
        config.format.width = formatReader["width"];
        config.format.height = formatReader["height"];
        config.format.framerate = formatReader["framerate"];
        config.format.preference = (ORIENTATION_MODE)formatReader["preference"];
    }

    if (!cameraCapturerConfigReader["followEncodeDimensionRatio"].is_null())
        config.followEncodeDimensionRatio = cameraCapturerConfigReader["followEncodeDimensionRatio"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableMultiCamera(enabled, config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int enableVideo(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->enableVideo();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int disableVideo(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->disableVideo();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startPreview(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->startPreview();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startPreview(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VIDEO_SOURCE_TYPE sourceType = VIDEO_SOURCE_CAMERA_PRIMARY;
    if (!reader["sourceType"].is_null()) sourceType = reader["sourceType"];

    MyJson outdata;
    outdata["result"] = wrapper_->startPreview(sourceType);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopPreview(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopPreview();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopPreview(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VIDEO_SOURCE_TYPE sourceType = VIDEO_SOURCE_CAMERA_PRIMARY;
    if (!reader["sourceType"].is_null()) sourceType = reader["sourceType"];

    MyJson outdata;
    outdata["result"] = wrapper_->stopPreview(sourceType);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startLastmileProbeTest(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    LastmileProbeConfig config;

    MyJson lastmileProbeConfigReader = reader["config"];

    if (!lastmileProbeConfigReader["probeUplink"].is_null())
        config.probeUplink = lastmileProbeConfigReader["probeUplink"];
    if (!lastmileProbeConfigReader["probeDownlink"].is_null())
        config.probeDownlink = lastmileProbeConfigReader["probeDownlink"];
    if (!lastmileProbeConfigReader["expectedUplinkBitrate"].is_null())
        config.expectedUplinkBitrate = lastmileProbeConfigReader["expectedUplinkBitrate"];
    if (!lastmileProbeConfigReader["expectedDownlinkBitrate"].is_null())
        config.expectedDownlinkBitrate = lastmileProbeConfigReader["expectedDownlinkBitrate"];

    MyJson outdata;
    outdata["result"] = wrapper_->startLastmileProbeTest(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopLastmileProbeTest(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopLastmileProbeTest();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setVideoEncoderConfiguration(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VideoEncoderConfiguration config;

    MyJson videoEncoderConfigReader = reader["config"];

    if (!videoEncoderConfigReader["codecType"].is_null())
        config.codecType = videoEncoderConfigReader["codecType"];
    if (!videoEncoderConfigReader["dimensions"].is_null()) {
        MyJson dimensionsReader = videoEncoderConfigReader["dimensions"];
        config.dimensions.width = dimensionsReader["width"];
        config.dimensions.height = dimensionsReader["height"];
    }
    if (!videoEncoderConfigReader["frameRate"].is_null())
        config.frameRate = videoEncoderConfigReader["frameRate"];
    if (!videoEncoderConfigReader["bitrate"].is_null())
        config.bitrate = videoEncoderConfigReader["bitrate"];
    if (!videoEncoderConfigReader["minBitrate"].is_null())
        config.minBitrate = videoEncoderConfigReader["minBitrate"];
    if (!videoEncoderConfigReader["orientationMode"].is_null())
        config.orientationMode = videoEncoderConfigReader["orientationMode"];
    if (!videoEncoderConfigReader["degradationPreference"].is_null())
        config.degradationPreference = videoEncoderConfigReader["degradationPreference"];
    if (!videoEncoderConfigReader["mirrorMode"].is_null())
        config.mirrorMode = videoEncoderConfigReader["mirrorMode"];
    if (!videoEncoderConfigReader["advanceOptions"].is_null()) {
        MyJson advanceOptionsReader = videoEncoderConfigReader["advanceOptions"];
        if (!advanceOptionsReader["enableExternalAudioSource"].is_null())
            config.advanceOptions.enableExternalAudioSource = advanceOptionsReader["enableExternalAudioSource"];
        if (!advanceOptionsReader["enableTextureEncode"].is_null())
            config.advanceOptions.enableTextureEncode = advanceOptionsReader["enableTextureEncode"];
        if (!advanceOptionsReader["enableEncodeTexture"].is_null())
            config.advanceOptions.enableEncodeTexture = advanceOptionsReader["enableEncodeTexture"];
        if (!advanceOptionsReader["enableVideoFrameObserver"].is_null())
            config.advanceOptions.enableVideoFrameObserver = advanceOptionsReader["enableVideoFrameObserver"];
        if (!advanceOptionsReader["enableSimulcastStream"].is_null())
            config.advanceOptions.enableSimulcastStream = advanceOptionsReader["enableSimulcastStream"];
        if (!advanceOptionsReader["enableIntraRequest"].is_null())
            config.advanceOptions.enableIntraRequest = advanceOptionsReader["enableIntraRequest"];
        if (!advanceOptionsReader["enableDualStreamMode"].is_null())
            config.advanceOptions.enableDualStreamMode = advanceOptionsReader["enableDualStreamMode"];
        if (!advanceOptionsReader["enableSuperResolution"].is_null())
            config.advanceOptions.enableSuperResolution = advanceOptionsReader["enableSuperResolution"];
        if (!advanceOptionsReader["enableLighteningContrastLevel"].is_null())
            config.advanceOptions.enableLighteningContrastLevel = advanceOptionsReader["enableLighteningContrastLevel"];
        if (!advanceOptionsReader["enableNoiseReduction"].is_null())
            config.advanceOptions.enableNoiseReduction = advanceOptionsReader["enableNoiseReduction"];
        if (!advanceOptionsReader["enableWatermark"].is_null())
            config.advanceOptions.enableWatermark = advanceOptionsReader["enableWatermark"];
        if (!advanceOptionsReader["enableTimestampWatermark"].is_null())
            config.advanceOptions.enableTimestampWatermark = advanceOptionsReader["enableTimestampWatermark"];
        if (!advanceOptionsReader["enableDualStreamWithExtraVideoCodec"].is_null())
            config.advanceOptions.enableDualStreamWithExtraVideoCodec = advanceOptionsReader["enableDualStreamWithExtraVideoCodec"];
        if (!advanceOptionsReader["enableQualityAdaptIndication"].is_null())
            config.advanceOptions.enableQualityAdaptIndication = advanceOptionsReader["enableQualityAdaptIndication"];
        if (!advanceOptionsReader["enableAnnotate"].is_null())
            config.advanceOptions.enableAnnotate = advanceOptionsReader["enableAnnotate"];
        if (!advanceOptionsReader["enableFaceDetection"].is_null())
            config.advanceOptions.enableFaceDetection = advanceOptionsReader["enableFaceDetection"];
        if (!advanceOptionsReader["enableFaceDetectionDrivenStatus"].is_null())
            config.advanceOptions.enableFaceDetectionDrivenStatus = advanceOptionsReader["enableFaceDetectionDrivenStatus"];
        if (!advanceOptionsReader["enableFaceDetectionDrivenStatus"].is_null())
            config.advanceOptions.enableFaceDetectionDrivenStatus = advanceOptionsReader["enableFaceDetectionDrivenStatus"];
        if (!advanceOptionsReader["enableVirtualBackground"].is_null())
            config.advanceOptions.enableVirtualBackground = advanceOptionsReader["enableVirtualBackground"];
        if (!advanceOptionsReader["enableVideoQualityEnhancement"].is_null())
            config.advanceOptions.enableVideoQualityEnhancement = advanceOptionsReader["enableVideoQualityEnhancement"];
        if (!advanceOptionsReader["enableContentHint"].is_null())
            config.advanceOptions.enableContentHint = advanceOptionsReader["enableContentHint"];
        if (!advanceOptionsReader["enableCameraTuning"].is_null())
            config.advanceOptions.enableCameraTuning = advanceOptionsReader["enableCameraTuning"];
        if (!advanceOptionsReader["enableSelfHostedAI"].is_null())
            config.advanceOptions.enableSelfHostedAI = advanceOptionsReader["enableSelfHostedAI"];
        if (!advanceOptionsReader["enableVideoSuperResolution"].is_null())
            config.advanceOptions.enableVideoSuperResolution = advanceOptionsReader["enableVideoSuperResolution"];
        if (!advanceOptionsReader["enableRemoteSuperResolution"].is_null())
            config.advanceOptions.enableRemoteSuperResolution = advanceOptionsReader["enableRemoteSuperResolution"];
        if (!advanceOptionsReader["enableRemoteSuperResolution"].is_null())
            config.advanceOptions.enableRemoteSuperResolution = advanceOptionsReader["enableRemoteSuperResolution"];
        if (!advanceOptionsReader["enableRemoteSuperResolution"].is_null())
            config.advanceOptions.enableRemoteSuperResolution = advanceOptionsReader["enableRemoteSuperResolution"];
        if (!advanceOptionsReader["enableRemoteSuperResolution"].is_null())
            config.advanceOptions.enableRemoteSuperResolution = advanceOptionsReader["enableRemoteSuperResolution"];
        if (!advanceOptionsReader["enableRemoteSuperResolution"].is_null())
            config.advanceOptions.enableRemoteSuperResolution = advanceOptionsReader["enableRemoteSuperResolution"];
        if (!advanceOptionsReader["enableRemoteSuperResolution"].is_null())
            config.advanceOptions.enableRemoteSuperResolution = advanceOptionsReader["enableRemoteSuperResolution"];
        if (!advanceOptionsReader["enableRemoteSuperResolution"].is_null())
            config.advanceOptions.enableRemoteSuperResolution = advanceOptionsReader["enableRemoteSuperResolution"];
        if (!advanceOptionsReader["enableRemoteSuperResolution"].is_null())
            config.advanceOptions.enableRemoteSuperResolution = advanceOptionsReader["enableRemoteSuperResolution"];
        if (!advanceOptionsReader["enableRemoteSuperResolution"].is_null())
            config.advanceOptions.enableRemoteSuperResolution = advanceOptionsReader["enableRemoteSuperResolution"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->setVideoEncoderConfiguration(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setBeautyEffectOptions(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    BeautyOptions options;
    if (!reader["enabled"].is_null()) options.enabled = reader["enabled"];

    MyJson beautyOptionsReader = reader["options"];
    if (!beautyOptionsReader["lighteningContrastLevel"].is_null())
        options.lighteningContrastLevel = beautyOptionsReader["lighteningContrastLevel"];
    if (!beautyOptionsReader["lighteningLevel"].is_null())
        options.lighteningLevel = beautyOptionsReader["lighteningLevel"];
    if (!beautyOptionsReader["smoothnessLevel"].is_null())
        options.smoothnessLevel = beautyOptionsReader["smoothnessLevel"];
    if (!beautyOptionsReader["rednessLevel"].is_null())
        options.rednessLevel = beautyOptionsReader["rednessLevel"];
    if (!beautyOptionsReader["sharpnessLevel"].is_null())
        options.sharpnessLevel = beautyOptionsReader["sharpnessLevel"];

    agora::media::MEDIA_SOURCE_TYPE type = agora::media::PRIMARY_CAMERA_SOURCE;
    if (!reader["type"].is_null()) type = reader["type"];

    MyJson outdata;
    outdata["result"] = wrapper_->setBeautyEffectOptions(options.enabled, options, type);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLowlightEnhanceOptions(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    LowlightEnhanceOptions options;
    agora::media::MEDIA_SOURCE_TYPE type = agora::media::PRIMARY_CAMERA_SOURCE;

    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson lowlightEnhanceOptionsReader = reader["options"];

    if (!lowlightEnhanceOptionsReader["mode"].is_null())
        options.mode = (LowlightEnhanceOptions::LOW_LIGHT_ENHANCE_MODE) lowlightEnhanceOptionsReader["mode"];
    if (!lowlightEnhanceOptionsReader["level"].is_null())
        options.level = (LowlightEnhanceOptions::LOW_LIGHT_ENHANCE_LEVEL) lowlightEnhanceOptionsReader["level"];

    if (!reader["type"].is_null()) type = (agora::media::MEDIA_SOURCE_TYPE) reader["type"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLowlightEnhanceOptions(enabled, options, type);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setVideoDenoiserOptions(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    VideoDenoiserOptions options;
    agora::media::MEDIA_SOURCE_TYPE type = agora::media::PRIMARY_CAMERA_SOURCE;

    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson videoDenoiserOptionsReader = reader["options"];

    if (!videoDenoiserOptionsReader["mode"].is_null())
        options.mode = (VideoDenoiserOptions::VIDEO_DENOISER_MODE) videoDenoiserOptionsReader["mode"];
    if (!videoDenoiserOptionsReader["level"].is_null())
        options.level = (VideoDenoiserOptions::VIDEO_DENOISER_LEVEL) videoDenoiserOptionsReader["level"];

    if (!reader["type"].is_null()) type = (agora::media::MEDIA_SOURCE_TYPE) reader["type"];

    MyJson outdata;
    outdata["result"] = wrapper_->setVideoDenoiserOptions(enabled, options, type);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setColorEnhanceOptions(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    ColorEnhanceOptions options;
    agora::media::MEDIA_SOURCE_TYPE type = agora::media::PRIMARY_CAMERA_SOURCE;

    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson optionsReader = reader["options"];
    if (!optionsReader["strengthLevel"].is_null())
        options.strengthLevel = optionsReader["strengthLevel"];
    if (!optionsReader["skinProtectLevel"].is_null())
        options.skinProtectLevel = optionsReader["skinProtectLevel"];

    if (!reader["type"].is_null()) type = reader["type"];

    MyJson outdata;
    outdata["result"] = wrapper_->setColorEnhanceOptions(enabled, options, type);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableVirtualBackground(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VirtualBackgroundSource backgroundSource;
    SegmentationProperty segproperty;
    agora::media::MEDIA_SOURCE_TYPE type = agora::media::PRIMARY_CAMERA_SOURCE;

    MyJson virtualBackgroundSourceReader = reader["backgroundSource"];
    MyJson segmentationPropertyReader = reader["segproperty"];

    if (!virtualBackgroundSourceReader["background_source_type"].is_null())
        backgroundSource.background_source_type = virtualBackgroundSourceReader["background_source_type"];
    if (!virtualBackgroundSourceReader["color"].is_null())
        backgroundSource.color = virtualBackgroundSourceReader["color"];
    if (!virtualBackgroundSourceReader["source"].is_null())
        backgroundSource.source = virtualBackgroundSourceReader["source"];
    if (!virtualBackgroundSourceReader["blur_degree"].is_null())
        backgroundSource.blur_degree = virtualBackgroundSourceReader["blur_degree"];

    if (!segmentationPropertyReader["modelType"].is_null())
        segproperty.modelType = segmentationPropertyReader["modelType"];
    if (!segmentationPropertyReader["greenCapacity"].is_null())
        segproperty.greenCapacity = segmentationPropertyReader["greenCapacity"];

    if (!reader["type"].is_null()) type = reader["type"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableVirtualBackground(enabled, backgroundSource, segproperty, type);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setupRemoteVideo(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VideoCanvas canvas;

    MyJson videoCanvasReader = reader["canvas"];

    if (!videoCanvasReader["view"].is_null())
        canvas.view = (view_t)(long) videoCanvasReader["view"];
    if (!videoCanvasReader["uid"].is_null())
        canvas.uid = (uid_t)(long) videoCanvasReader["uid"];
    if (!videoCanvasReader["renderMode"].is_null())
        canvas.renderMode = videoCanvasReader["renderMode"];
    if (!videoCanvasReader["mirrorMode"].is_null())
        canvas.mirrorMode = videoCanvasReader["mirrorMode"];
    if (!videoCanvasReader["setupMode"].is_null())
        canvas.setupMode = videoCanvasReader["setupMode"];
    if (!videoCanvasReader["sourceType"].is_null())
        canvas.sourceType = videoCanvasReader["sourceType"];
    if (!videoCanvasReader["mediaPlayerId"].is_null())
        canvas.mediaPlayerId = videoCanvasReader["mediaPlayerId"];

    MyJson cropAreaReader = videoCanvasReader["cropArea"];
    if (!cropAreaReader.is_null()) {
        canvas.cropArea.x = cropAreaReader["x"];
        canvas.cropArea.y = cropAreaReader["y"];
        canvas.cropArea.width = cropAreaReader["width"];
        canvas.cropArea.height = cropAreaReader["height"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->setupRemoteVideo(canvas);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setupLocalVideo(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VideoCanvas canvas;

    MyJson videoCanvasReader = reader["canvas"];

    if (!videoCanvasReader["view"].is_null())
        canvas.view = (view_t)(long) videoCanvasReader["view"];
    if (!videoCanvasReader["uid"].is_null())
        canvas.uid = (uid_t)(long) videoCanvasReader["uid"];
    if (!videoCanvasReader["renderMode"].is_null())
        canvas.renderMode = videoCanvasReader["renderMode"];
    if (!videoCanvasReader["mirrorMode"].is_null())
        canvas.mirrorMode = videoCanvasReader["mirrorMode"];
    if (!videoCanvasReader["setupMode"].is_null())
        canvas.setupMode = videoCanvasReader["setupMode"];
    if (!videoCanvasReader["sourceType"].is_null())
        canvas.sourceType = videoCanvasReader["sourceType"];
    if (!videoCanvasReader["mediaPlayerId"].is_null())
        canvas.mediaPlayerId = videoCanvasReader["mediaPlayerId"];

    MyJson cropAreaReader = videoCanvasReader["cropArea"];
    if (!cropAreaReader.is_null()) {
        canvas.cropArea.x = cropAreaReader["x"];
        canvas.cropArea.y = cropAreaReader["y"];
        canvas.cropArea.width = cropAreaReader["width"];
        canvas.cropArea.height = cropAreaReader["height"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->setupLocalVideo(canvas);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableAudio(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->enableAudio();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int disableAudio(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->disableAudio();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setAudioProfile(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AUDIO_PROFILE_TYPE profile = AUDIO_PROFILE_DEFAULT;
    if (!reader["profile"].is_null()) profile = reader["profile"];

    MyJson outdata;
    outdata["result"] = wrapper_->setAudioProfile(profile);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setAudioScenario(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AUDIO_SCENARIO_TYPE scenario = AUDIO_SCENARIO_DEFAULT;
    if (!reader["scenario"].is_null()) scenario = reader["scenario"];

    MyJson outdata;
    outdata["result"] = wrapper_->setAudioScenario(scenario);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableLocalAudio(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableLocalAudio(enabled);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int muteLocalAudioStream(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool mute = false;
    if (!reader["mute"].is_null()) mute = reader["mute"];

    MyJson outdata;
    outdata["result"] = wrapper_->muteLocalAudioStream(mute);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int muteAllRemoteAudioStreams(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool mute = false;
    if (!reader["mute"].is_null()) mute = reader["mute"];

    MyJson outdata;
    outdata["result"] = wrapper_->muteAllRemoteAudioStreams(mute);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int muteRemoteAudioStream(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    uid_t uid = (uid_t)(long) reader["uid"];
    bool mute = reader["mute"];

    MyJson outdata;
    outdata["result"] = wrapper_->muteRemoteAudioStream(uid, mute);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int muteLocalVideoStream(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool mute = false;
    if (!reader["mute"].is_null()) mute = reader["mute"];

    MyJson outdata;
    outdata["result"] = wrapper_->muteLocalVideoStream(mute);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableLocalVideo(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableLocalVideo(enabled);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int muteAllRemoteVideoStreams(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool mute = false;
    if (!reader["mute"].is_null()) mute = reader["mute"];

    MyJson outdata;
    outdata["result"] = wrapper_->muteAllRemoteVideoStreams(mute);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int muteRemoteVideoStream(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    uid_t uid = (uid_t)(long) reader["uid"];
    bool mute = reader["mute"];

    MyJson outdata;
    outdata["result"] = wrapper_->muteRemoteVideoStream(uid, mute);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setRemoteVideoStreamType(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    uid_t uid = (uid_t)(long) reader["uid"];
    VIDEO_STREAM_TYPE streamType = VIDEO_STREAM_HIGH;
    if (!reader["streamType"].is_null()) streamType = reader["streamType"];

    MyJson outdata;
    outdata["result"] = wrapper_->setRemoteVideoStreamType(uid, streamType);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setRemoteVideoSubscriptionOptions(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    uid_t uid = (uid_t)(long) reader["uid"];

    VideoSubscriptionOptions options;

    MyJson videoSubscriptionOptionsReader = reader["options"];

    if (!videoSubscriptionOptionsReader["type"].is_null())
        options.type = videoSubscriptionOptionsReader["type"];
    if (!videoSubscriptionOptionsReader["encodedFrameOnly"].is_null())
        options.encodedFrameOnly = videoSubscriptionOptionsReader["encodedFrameOnly"];

    MyJson outdata;
    outdata["result"] = wrapper_->setRemoteVideoSubscriptionOptions(uid, options);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setRemoteDefaultVideoStreamType(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VIDEO_STREAM_TYPE streamType = VIDEO_STREAM_HIGH;
    if (!reader["streamType"].is_null()) streamType = reader["streamType"];

    MyJson outdata;
    outdata["result"] = wrapper_->setRemoteDefaultVideoStreamType(streamType);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setSubscribeAudioBlocklist(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    std::vector<uid_t> uidList;
    int uidNumber = 0;
    if (!reader["uidList"].is_null()) {
        MyJson uidListReader = reader["uidList"];
        uidNumber = uidListReader.size();
        for (int i = 0; i < uidNumber; i++) {
            uidList.push_back((uid_t)(long) uidListReader[i]);
        }
    }

    MyJson outdata;
    outdata["result"] = wrapper_->setSubscribeAudioBlocklist(
        uidList.empty() ? nullptr : &uidList[0], uidNumber);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setSubscribeAudioAllowlist(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    std::vector<uid_t> uidList;
    int uidNumber = 0;
    if (!reader["uidList"].is_null()) {
        MyJson uidListReader = reader["uidList"];
        uidNumber = uidListReader.size();
        for (int i = 0; i < uidNumber; i++) {
            uidList.push_back((uid_t)(long) uidListReader[i]);
        }
    }

    MyJson outdata;
    outdata["result"] = wrapper_->setSubscribeAudioAllowlist(
        uidList.empty() ? nullptr : &uidList[0], uidNumber);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setSubscribeVideoBlocklist(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    std::vector<uid_t> uidList;
    int uidNumber = 0;
    if (!reader["uidList"].is_null()) {
        MyJson uidListReader = reader["uidList"];
        uidNumber = uidListReader.size();
        for (int i = 0; i < uidNumber; i++) {
            uidList.push_back((uid_t)(long) uidListReader[i]);
        }
    }

    MyJson outdata;
    outdata["result"] = wrapper_->setSubscribeVideoBlocklist(uidList.empty() ? nullptr : &uidList[0], uidNumber);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setSubscribeVideoAllowlist(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    std::vector<uid_t> uidList;
    int uidNumber = 0;
    if (!reader["uidList"].is_null()) {
        MyJson uidListReader = reader["uidList"];
        uidNumber = uidListReader.size();
        for (int i = 0; i < uidNumber; i++) {
            uidList.push_back((uid_t)(long) uidListReader[i]);
        }
    }

    MyJson outdata;
    outdata["result"] = wrapper_->setSubscribeVideoAllowlist(uidList.empty() ? nullptr : &uidList[0], uidNumber);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableAudioVolumeIndication(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int interval = 0;
    int smooth = 0;
    bool reportVad = false;
    if (!reader["interval"].is_null()) interval = reader["interval"];
    if (!reader["smooth"].is_null()) smooth = reader["smooth"];
    if (!reader["reportVad"].is_null()) reportVad = reader["reportVad"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableAudioVolumeIndication(interval, smooth, reportVad);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startAudioRecording(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string filePath = "";
    AUDIO_RECORDING_QUALITY_TYPE quality = AUDIO_RECORDING_QUALITY_MEDIUM;
    if (!reader["filePath"].is_null()) filePath = reader["filePath"];
    if (!reader["quality"].is_null()) quality = reader["quality"];

    MyJson outdata;
    outdata["result"] = wrapper_->startAudioRecording(filePath.c_str(), quality);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startAudioRecording(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    std::string filePath = "";
    int sampleRate = 0;
    AUDIO_RECORDING_QUALITY_TYPE quality = AUDIO_RECORDING_QUALITY_MEDIUM;

    if (!reader["filePath"].is_null()) filePath = reader["filePath"];
    if (!reader["sampleRate"].is_null()) sampleRate = reader["sampleRate"];
    if (!reader["quality"].is_null()) quality = reader["quality"];

    MyJson outdata;
    outdata["result"] = wrapper_->startAudioRecording(
        filePath.c_str(), sampleRate, quality);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startAudioRecording(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AudioRecordingConfiguration config;

    MyJson audioRecordingConfigReader = reader["config"];

    if (!audioRecordingConfigReader["filePath"].is_null())
        config.filePath = audioRecordingConfigReader["filePath"];
    if (!audioRecordingConfigReader["encode"].is_null())
        config.encode = audioRecordingConfigReader["encode"];
    if (!audioRecordingConfigReader["sampleRate"].is_null())
        config.sampleRate = audioRecordingConfigReader["sampleRate"];
    if (!audioRecordingConfigReader["fileRecordingType"].is_null())
        config.fileRecordingType = audioRecordingConfigReader["fileRecordingType"];
    if (!audioRecordingConfigReader["quality"].is_null())
        config.quality = audioRecordingConfigReader["quality"];
    if (!audioRecordingConfigReader["recordingChannel"].is_null())
        config.recordingChannel = audioRecordingConfigReader["recordingChannel"];

    MyJson outdata;
    outdata["result"] = wrapper_->startAudioRecording(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int registerAudioEncodedFrameObserver(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AudioEncodedFrameObserverConfig config;
    IAudioEncodedFrameObserver *observer = nullptr;

    MyJson audioEncodedFrameObserverConfigReader = reader["config"];

    if (!audioEncodedFrameObserverConfigReader["postionType"].is_null())
        config.postionType = audioEncodedFrameObserverConfigReader["postionType"];
    if (!audioEncodedFrameObserverConfigReader["encodingType"].is_null())
        config.encodingType = audioEncodedFrameObserverConfigReader["encodingType"];

    if (!reader["observer"].is_null()) {
        observer = new IAudioEncodedFrameObserverImpl();
        observer->setCallbackFunc(reader["observer"]);
    }

    MyJson outdata;
    outdata["result"] = wrapper_->registerAudioEncodedFrameObserver(config, observer);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopAudioRecording(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopAudioRecording();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int createMediaPlayer(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    agora_refptr<IMediaPlayer> player = wrapper_->createMediaPlayer();
    if (player) {
        outdata["result"] = (long long)player.get();
    } else {
        outdata["result"] = nullptr;
    }
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int destroyMediaPlayer(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    agora_refptr<IMediaPlayer> media_player = nullptr;
    if (!reader["media_player"].is_null()) {
        media_player = reinterpret_cast<IMediaPlayer *>(atol(reader["media_player"].get<std::string>().c_str()));
    }

    MyJson outdata;
    outdata["result"] = wrapper_->destroyMediaPlayer(media_player);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startAudioMixing(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string filePath = "";
    bool loopback = false;
    int cycle = 1;
    if (!reader["filePath"].is_null()) filePath = reader["filePath"];
    if (!reader["loopback"].is_null()) loopback = reader["loopback"];
    if (!reader["cycle"].is_null()) cycle = reader["cycle"];

    MyJson outdata;
    outdata["result"] = wrapper_->startAudioMixing(
        filePath.c_str(), loopback, cycle);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startAudioMixing(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string filePath = "";
    bool loopback = false;
    int cycle = 1;
    int startPos = 0;

    if (!reader["filePath"].is_null()) filePath = reader["filePath"];
    if (!reader["loopback"].is_null()) loopback = reader["loopback"];
    if (!reader["cycle"].is_null()) cycle = reader["cycle"];
    if (!reader["startPos"].is_null()) startPos = reader["startPos"];

    MyJson outdata;
    outdata["result"] = wrapper_->startAudioMixing(
        filePath.c_str(), loopback, cycle, startPos);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopAudioMixing(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopAudioMixing();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int pauseAudioMixing(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->pauseAudioMixing();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int resumeAudioMixing(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->resumeAudioMixing();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int selectAudioTrack(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int index = 0;
    if (!reader["index"].is_null()) index = reader["index"];

    MyJson outdata;
    outdata["result"] = wrapper_->selectAudioTrack(index);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getAudioTrackCount(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getAudioTrackCount();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int adjustAudioMixingVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int volume = 0;
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->adjustAudioMixingVolume(volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int adjustAudioMixingPublishVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int volume = 0;
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->adjustAudioMixingPublishVolume(volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getAudioMixingPublishVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getAudioMixingPublishVolume();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int adjustAudioMixingPlayoutVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int volume = 0;
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->adjustAudioMixingPlayoutVolume(volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getAudioMixingPlayoutVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getAudioMixingPlayoutVolume();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getAudioMixingDuration(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getAudioMixingDuration();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getAudioMixingCurrentPosition(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getAudioMixingCurrentPosition();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setAudioMixingPosition(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int pos = 0;
    if (!reader["pos"].is_null()) pos = reader["pos"];

    MyJson outdata;
    outdata["result"] = wrapper_->setAudioMixingPosition(pos);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setAudioMixingDualMonoMode(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    media::AUDIO_MIXING_DUAL_MONO_MODE mode = media::AUDIO_MIXING_DUAL_MONO_MODE::AUDIO_MIXING_DUAL_MONO_MODE_DEFAULT;
    if (!reader["mode"].is_null()) mode = reader["mode"];

    MyJson outdata;
    outdata["result"] = wrapper_->setAudioMixingDualMonoMode(mode);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setAudioMixingPitch(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int pitch = 0;
    if (!reader["pitch"].is_null()) pitch = reader["pitch"];

    MyJson outdata;
    outdata["result"] = wrapper_->setAudioMixingPitch(pitch);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getEffectsVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getEffectsVolume();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setEffectsVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int volume = 100;
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->setEffectsVolume(volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int preloadEffect(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int soundId = 0;
    string filePath = "";
    int startPos = 0;
    if (!reader["soundId"].is_null()) soundId = reader["soundId"];
    if (!reader["filePath"].is_null()) filePath = reader["filePath"];
    if (!reader["startPos"].is_null()) startPos = reader["startPos"];

    MyJson outdata;
    outdata["result"] = wrapper_->preloadEffect(soundId, filePath.c_str(), startPos);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int playEffect(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int soundId = 0;
    string filePath = "";
    int loopCount = 1;
    double pitch = 1.0;
    double pan = 0.0;
    int gain = 100;
    bool publish = false;
    int startPos = 0;

    if (!reader["soundId"].is_null()) soundId = reader["soundId"];
    if (!reader["filePath"].is_null()) filePath = reader["filePath"];
    if (!reader["loopCount"].is_null()) loopCount = reader["loopCount"];
    if (!reader["pitch"].is_null()) pitch = reader["pitch"];
    if (!reader["pan"].is_null()) pan = reader["pan"];
    if (!reader["gain"].is_null()) gain = reader["gain"];
    if (!reader["publish"].is_null()) publish = reader["publish"];
    if (!reader["startPos"].is_null()) startPos = reader["startPos"];

    MyJson outdata;
    outdata["result"] = wrapper_->playEffect(soundId, filePath.c_str(), loopCount, pitch, pan, gain, publish, startPos);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int playAllEffects(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int loopCount = 1;
    double pitch = 1.0;
    double pan = 0.0;
    int gain = 100;
    bool publish = false;

    if (!reader["loopCount"].is_null()) loopCount = reader["loopCount"];
    if (!reader["pitch"].is_null()) pitch = reader["pitch"];
    if (!reader["pan"].is_null()) pan = reader["pan"];
    if (!reader["gain"].is_null()) gain = reader["gain"];
    if (!reader["publish"].is_null()) publish = reader["publish"];

    MyJson outdata;
    outdata["result"] = wrapper_->playAllEffects(loopCount, pitch, pan, gain, publish);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getVolumeOfEffect(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int soundId = 0;
    if (!reader["soundId"].is_null()) soundId = reader["soundId"];

    MyJson outdata;
    outdata["result"] = wrapper_->getVolumeOfEffect(soundId);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setVolumeOfEffect(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int soundId = 0;
    int volume = 0;
    if (!reader["soundId"].is_null()) soundId = reader["soundId"];
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->setVolumeOfEffect(soundId, volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int pauseEffect(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int soundId = 0;
    if (!reader["soundId"].is_null()) soundId = reader["soundId"];

    MyJson outdata;
    outdata["result"] = wrapper_->pauseEffect(soundId);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int pauseAllEffects(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->pauseAllEffects();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int resumeEffect(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int soundId = 0;
    if (!reader["soundId"].is_null()) soundId = reader["soundId"];

    MyJson outdata;
    outdata["result"] = wrapper_->resumeEffect(soundId);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int resumeAllEffects(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->resumeAllEffects();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopEffect(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int soundId = 0;
    if (!reader["soundId"].is_null()) soundId = reader["soundId"];

    MyJson outdata;
    outdata["result"] = wrapper_->stopEffect(soundId);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopAllEffects(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopAllEffects();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int unloadEffect(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int soundId = 0;
    if (!reader["soundId"].is_null()) soundId = reader["soundId"];

    MyJson outdata;
    outdata["result"] = wrapper_->unloadEffect(soundId);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int unloadAllEffects(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->unloadAllEffects();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getEffectDuration(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string filePath = "";
    if (!reader["filePath"].is_null()) filePath = reader["filePath"];

    MyJson outdata;
    outdata["result"] = wrapper_->getEffectDuration(filePath.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setEffectPosition(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int soundId = 0;
    int pos = 0;
    if (!reader["soundId"].is_null()) soundId = reader["soundId"];
    if (!reader["pos"].is_null()) pos = reader["pos"];

    MyJson outdata;
    outdata["result"] = wrapper_->setEffectPosition(soundId, pos);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getEffectCurrentPosition(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int soundId = 0;
    if (!reader["soundId"].is_null()) soundId = reader["soundId"];

    MyJson outdata;
    outdata["result"] = wrapper_->getEffectCurrentPosition(soundId);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableSoundPositionIndication(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableSoundPositionIndication(enabled);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setRemoteVoicePosition(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    uid_t uid = (uid_t)(long) reader["uid"];
    double pan = reader["pan"];
    double gain = reader["gain"];

    MyJson outdata;
    outdata["result"] = wrapper_->setRemoteVoicePosition(uid, pan, gain);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableSpatialAudio(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableSpatialAudio(enabled);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setRemoteUserSpatialAudioParams(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    uid_t uid = (uid_t)(long) reader["uid"];

    agora::SpatialAudioParams params;
    MyJson spatialAudioParamsReader = reader["params"];

    if (!spatialAudioParamsReader["indicationIntervalMs"].is_null())
        params.indicationIntervalMs = spatialAudioParamsReader["indicationIntervalMs"];
    if (!spatialAudioParamsReader["eventType"].is_null())
        params.eventType = spatialAudioParamsReader["eventType"];
    if (!spatialAudioParamsReader["transmitIntervalMs"].is_null())
        params.transmitIntervalMs = spatialAudioParamsReader["transmitIntervalMs"];
    if (!spatialAudioParamsReader["mixedAudioFrameRate"].is_null())
        params.mixedAudioFrameRate = spatialAudioParamsReader["mixedAudioFrameRate"];
    if (!spatialAudioParamsReader["mixedAudioSampleRateHz"].is_null())
        params.mixedAudioSampleRateHz = spatialAudioParamsReader["mixedAudioSampleRateHz"];
    if (!spatialAudioParamsReader["enableSpatialAudio"].is_null())
        params.enableSpatialAudio = spatialAudioParamsReader["enableSpatialAudio"];

    MyJson outdata;
    outdata["result"] = wrapper_->setRemoteUserSpatialAudioParams(uid, params);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setVoiceBeautifierPreset(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VOICE_BEAUTIFIER_PRESET preset = VOICE_BEAUTIFIER_OFF;
    if (!reader["preset"].is_null()) preset = reader["preset"];

    MyJson outdata;
    outdata["result"] = wrapper_->setVoiceBeautifierPreset(preset);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setAudioEffectPreset(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AUDIO_EFFECT_PRESET preset = AUDIO_EFFECT_OFF;
    if (!reader["preset"].is_null()) preset = reader["preset"];

    MyJson outdata;
    outdata["result"] = wrapper_->setAudioEffectPreset(preset);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setVoiceConversionPreset(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VOICE_CONVERSION_PRESET preset = VOICE_CONVERSION_OFF;
    if (!reader["preset"].is_null()) preset = reader["preset"];

    MyJson outdata;
    outdata["result"] = wrapper_->setVoiceConversionPreset(preset);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setAudioEffectParameters(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AUDIO_EFFECT_PRESET preset = AUDIO_EFFECT_OFF;
    int param1 = 0;
    int param2 = 0;

    if (!reader["preset"].is_null()) preset = reader["preset"];
    if (!reader["param1"].is_null()) param1 = reader["param1"];
    if (!reader["param2"].is_null()) param2 = reader["param2"];

    MyJson outdata;
    outdata["result"] = wrapper_->setAudioEffectParameters(preset, param1, param2);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setVoiceBeautifierParameters(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VOICE_BEAUTIFIER_PRESET preset = VOICE_BEAUTIFIER_OFF;
    int param1 = 0;
    int param2 = 0;

    if (!reader["preset"].is_null()) preset = reader["preset"];
    if (!reader["param1"].is_null()) param1 = reader["param1"];
    if (!reader["param2"].is_null()) param2 = reader["param2"];

    MyJson outdata;
    outdata["result"] = wrapper_->setVoiceBeautifierParameters(preset, param1, param2);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setVoiceConversionParameters(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VOICE_CONVERSION_PRESET preset = VOICE_CONVERSION_OFF;
    int param1 = 0;
    int param2 = 0;

    if (!reader["preset"].is_null()) preset = reader["preset"];
    if (!reader["param1"].is_null()) param1 = reader["param1"];
    if (!reader["param2"].is_null()) param2 = reader["param2"];

    MyJson outdata;
    outdata["result"] = wrapper_->setVoiceConversionParameters(preset, param1, param2);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLocalVoicePitch(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    double pitch = 1.0;
    if (!reader["pitch"].is_null()) pitch = reader["pitch"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLocalVoicePitch(pitch);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLocalVoiceEqualization(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AUDIO_EQUALIZATION_BAND_FREQUENCY bandFrequency = AUDIO_EQUALIZATION_BAND_31;
    int bandGain = 0;
    if (!reader["bandFrequency"].is_null()) bandFrequency = reader["bandFrequency"];
    if (!reader["bandGain"].is_null()) bandGain = reader["bandGain"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLocalVoiceEqualization(bandFrequency, bandGain);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLocalVoiceReverb(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AUDIO_REVERB_TYPE reverbKey = AUDIO_REVERB_DRY_LEVEL;
    int value = 0;
    if (!reader["reverbKey"].is_null()) reverbKey = reader["reverbKey"];
    if (!reader["value"].is_null()) value = reader["value"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLocalVoiceReverb(reverbKey, value);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setHeadphoneEQPreset(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    HEADPHONE_EQUALIZER_PRESET preset = HEADPHONE_EQUALIZER_OFF;
    if (!reader["preset"].is_null()) preset = reader["preset"];

    MyJson outdata;
    outdata["result"] = wrapper_->setHeadphoneEQPreset(preset);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setHeadphoneEQParameters(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int lowGain = 0;
    int highGain = 0;
    if (!reader["lowGain"].is_null()) lowGain = reader["lowGain"];
    if (!reader["highGain"].is_null()) highGain = reader["highGain"];

    MyJson outdata;
    outdata["result"] = wrapper_->setHeadphoneEQParameters(lowGain, highGain);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLogFile(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string filePath = "";
    if (!reader["filePath"].is_null()) filePath = reader["filePath"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLogFile(filePath.empty() ? nullptr : filePath.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLogFilter(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    unsigned int filter = 0;
    if (!reader["filter"].is_null()) filter = reader["filter"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLogFilter(filter);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLogLevel(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    commons::LOG_LEVEL level = commons::LOG_LEVEL::LOG_LEVEL_INFO;
    if (!reader["level"].is_null()) level = (commons::LOG_LEVEL)reader["level"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLogLevel(level);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLogFileSize(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    unsigned int fileSizeInKBytes = 0;
    if (!reader["fileSizeInKBytes"].is_null()) fileSizeInKBytes = reader["fileSizeInKBytes"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLogFileSize(fileSizeInKBytes);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int uploadLogFile(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    agora::util::AString requestId;
    MyJson requestIdReader = reader["requestId"];
    if (!requestIdReader.is_null()) requestId = requestIdReader.get<std::string>();

    MyJson outdata;
    outdata["result"] = wrapper_->uploadLogFile(requestId);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLocalRenderMode(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    media::base::RENDER_MODE_TYPE renderMode = media::base::RENDER_MODE_HIDDEN;
    VIDEO_MIRROR_MODE_TYPE mirrorMode = VIDEO_MIRROR_MODE_AUTO;

    if (!reader["renderMode"].is_null()) renderMode = reader["renderMode"];
    if (!reader["mirrorMode"].is_null()) mirrorMode = reader["mirrorMode"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLocalRenderMode(renderMode, mirrorMode);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setRemoteRenderMode(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    uid_t uid = (uid_t)(long) reader["uid"];
    media::base::RENDER_MODE_TYPE renderMode = media::base::RENDER_MODE_HIDDEN;
    VIDEO_MIRROR_MODE_TYPE mirrorMode = VIDEO_MIRROR_MODE_AUTO;

    if (!reader["renderMode"].is_null()) renderMode = reader["renderMode"];
    if (!reader["mirrorMode"].is_null()) mirrorMode = reader["mirrorMode"];

    MyJson outdata;
    outdata["result"] = wrapper_->setRemoteRenderMode(uid, renderMode, mirrorMode);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLocalRenderMode(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    media::base::RENDER_MODE_TYPE renderMode = media::base::RENDER_MODE_HIDDEN;
    if (!reader["renderMode"].is_null()) renderMode = reader["renderMode"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLocalRenderMode(renderMode);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLocalVideoMirrorMode(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VIDEO_MIRROR_MODE_TYPE mirrorMode = VIDEO_MIRROR_MODE_AUTO;
    if (!reader["mirrorMode"].is_null()) mirrorMode = reader["mirrorMode"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLocalVideoMirrorMode(mirrorMode);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableDualStreamMode(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableDualStreamMode(enabled);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableDualStreamMode(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    SimulcastStreamConfig streamConfig;

    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson simulcastStreamConfigReader = reader["streamConfig"];

    if (!simulcastStreamConfigReader["dimensions"].is_null()) {
        MyJson dimensionsReader = simulcastStreamConfigReader["dimensions"];
        streamConfig.dimensions.width = dimensionsReader["width"];
        streamConfig.dimensions.height = dimensionsReader["height"];
    }

    if (!simulcastStreamConfigReader["kBitrate"].is_null())
        streamConfig.kBitrate = simulcastStreamConfigReader["kBitrate"];

    if (!simulcastStreamConfigReader["framerate"].is_null())
        streamConfig.framerate = simulcastStreamConfigReader["framerate"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableDualStreamMode(enabled, streamConfig);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setDualStreamMode(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    SIMULCAST_STREAM_MODE mode = DISABLE_SIMULCAST_STREAM;
    if (!reader["mode"].is_null()) mode = reader["mode"];

    MyJson outdata;
    outdata["result"] = wrapper_->setDualStreamMode(mode);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setDualStreamMode(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    SIMULCAST_STREAM_MODE mode = DISABLE_SIMULCAST_STREAM;
    SimulcastStreamConfig streamConfig;

    if (!reader["mode"].is_null()) mode = reader["mode"];

    MyJson streamConfigReader = reader["streamConfig"];

    if (!streamConfigReader["dimensions"].is_null()) {
        MyJson dimensionsReader = streamConfigReader["dimensions"];
        streamConfig.dimensions.width = dimensionsReader["width"];
        streamConfig.dimensions.height = dimensionsReader["height"];
    }

    if (!streamConfigReader["kBitrate"].is_null())
        streamConfig.kBitrate = streamConfigReader["kBitrate"];

    if (!streamConfigReader["framerate"].is_null())
        streamConfig.framerate = streamConfigReader["framerate"];

    MyJson outdata;
    outdata["result"] = wrapper_->setDualStreamMode(mode, streamConfig);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableEchoCancellationExternal(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    int audioSourceDelay = 0;
    if (!reader["enabled"].is_null()) enabled = reader["enabled"];
    if (!reader["audioSourceDelay"].is_null()) audioSourceDelay = reader["audioSourceDelay"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableEchoCancellationExternal(enabled, audioSourceDelay);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableCustomAudioLocalPlayback(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int sourceId = 0;
    bool enabled = false;
    if (!reader["sourceId"].is_null()) sourceId = reader["sourceId"];
    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableCustomAudioLocalPlayback(sourceId, enabled);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startPrimaryCustomAudioTrack(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AudioTrackConfig config;

    MyJson audioTrackConfigReader = reader["config"];

    if (!audioTrackConfigReader["enableLocalPlayback"].is_null())
        config.enableLocalPlayback = audioTrackConfigReader["enableLocalPlayback"];

    MyJson outdata;
    outdata["result"] = wrapper_->startPrimaryCustomAudioTrack(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopPrimaryCustomAudioTrack(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopPrimaryCustomAudioTrack();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startSecondaryCustomAudioTrack(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AudioTrackConfig config;

    MyJson audioTrackConfigReader = reader["config"];

    if (!audioTrackConfigReader["enableLocalPlayback"].is_null())
        config.enableLocalPlayback = audioTrackConfigReader["enableLocalPlayback"];

    MyJson outdata;
    outdata["result"] = wrapper_->startSecondaryCustomAudioTrack(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopSecondaryCustomAudioTrack(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopSecondaryCustomAudioTrack();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setRecordingAudioFrameParameters(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int sampleRate = 0;
    int channel = 0;
    RAW_AUDIO_FRAME_OP_MODE_TYPE mode = RAW_AUDIO_FRAME_OP_MODE_READ_ONLY;
    int samplesPerCall = 0;

    if (!reader["sampleRate"].is_null()) sampleRate = reader["sampleRate"];
    if (!reader["channel"].is_null()) channel = reader["channel"];
    if (!reader["mode"].is_null()) mode = reader["mode"];
    if (!reader["samplesPerCall"].is_null()) samplesPerCall = reader["samplesPerCall"];

    MyJson outdata;
    outdata["result"] = wrapper_->setRecordingAudioFrameParameters(sampleRate, channel, mode, samplesPerCall);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setPlaybackAudioFrameParameters(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int sampleRate = 0;
    int channel = 0;
    RAW_AUDIO_FRAME_OP_MODE_TYPE mode = RAW_AUDIO_FRAME_OP_MODE_READ_ONLY;
    int samplesPerCall = 0;

    if (!reader["sampleRate"].is_null()) sampleRate = reader["sampleRate"];
    if (!reader["channel"].is_null()) channel = reader["channel"];
    if (!reader["mode"].is_null()) mode = reader["mode"];
    if (!reader["samplesPerCall"].is_null()) samplesPerCall = reader["samplesPerCall"];

    MyJson outdata;
    outdata["result"] = wrapper_->setPlaybackAudioFrameParameters(sampleRate, channel, mode, samplesPerCall);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setMixedAudioFrameParameters(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int sampleRate = 48000;
    int channel = 1;
    int samplesPerCall = 1024;
    if (!reader["sampleRate"].is_null()) sampleRate = reader["sampleRate"];
    if (!reader["channel"].is_null()) channel = reader["channel"];
    if (!reader["samplesPerCall"].is_null()) samplesPerCall = reader["samplesPerCall"];

    MyJson outdata;
    outdata["result"] = wrapper_->setMixedAudioFrameParameters(sampleRate, channel, samplesPerCall);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setEarMonitoringAudioFrameParameters(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int sampleRate = 0;
    int channel = 0;
    RAW_AUDIO_FRAME_OP_MODE_TYPE mode = RAW_AUDIO_FRAME_OP_MODE_READ_ONLY;
    int samplesPerCall = 0;

    if (!reader["sampleRate"].is_null()) sampleRate = reader["sampleRate"];
    if (!reader["channel"].is_null()) channel = reader["channel"];
    if (!reader["mode"].is_null()) mode = reader["mode"];
    if (!reader["samplesPerCall"].is_null()) samplesPerCall = reader["samplesPerCall"];

    MyJson outdata;
    outdata["result"] = wrapper_->setEarMonitoringAudioFrameParameters(sampleRate, channel, mode, samplesPerCall);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setPlaybackAudioFrameBeforeMixingParameters(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int sampleRate = 0;
    int channel = 0;
    if (!reader["sampleRate"].is_null()) sampleRate = reader["sampleRate"];
    if (!reader["channel"].is_null()) channel = reader["channel"];

    MyJson outdata;
    outdata["result"] = wrapper_->setPlaybackAudioFrameBeforeMixingParameters(sampleRate, channel);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableAudioSpectrumMonitor(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int intervalInMS = 100;
    if (!reader["intervalInMS"].is_null()) intervalInMS = reader["intervalInMS"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableAudioSpectrumMonitor(intervalInMS);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int disableAudioSpectrumMonitor(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->disableAudioSpectrumMonitor();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int registerAudioSpectrumObserver(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    // Extract observer pointer from input JSON
    agora::media::IAudioSpectrumObserver *observer = nullptr;
    if (!reader["observer"].is_null()) {
        observer = reinterpret_cast<agora::media::IAudioSpectrumObserver *>(std::stoull(reader["observer"].get<std::string>(), nullptr, 16));
    }

    MyJson outdata;
    outdata["result"] = wrapper_->registerAudioSpectrumObserver(observer);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int unregisterAudioSpectrumObserver(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    // Extract observer pointer from input JSON
    agora::media::IAudioSpectrumObserver *observer = nullptr;
    if (!reader["observer"].is_null()) {
        long long ptr = reader["observer"];
        observer = reinterpret_cast<agora::media::IAudioSpectrumObserver *>(ptr);
    }

    MyJson outdata;
    outdata["result"] = wrapper_->unregisterAudioSpectrumObserver(observer);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int adjustRecordingSignalVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int volume = 0;
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->adjustRecordingSignalVolume(volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int muteRecordingSignal(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool mute = false;
    if (!reader["mute"].is_null()) mute = reader["mute"];

    MyJson outdata;
    outdata["result"] = wrapper_->muteRecordingSignal(mute);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int adjustPlaybackSignalVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int volume = 100;
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->adjustPlaybackSignalVolume(volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int adjustUserPlaybackSignalVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    unsigned int uid = 0;
    int volume = 100;
    if (!reader["uid"].is_null()) uid = (unsigned int)(long) reader["uid"];
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->adjustUserPlaybackSignalVolume(uid, volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLocalPublishFallbackOption(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    STREAM_FALLBACK_OPTIONS option = STREAM_FALLBACK_OPTION_DISABLED;
    if (!reader["option"].is_null()) option = reader["option"];

    MyJson outdata;
    outdata["result"] = wrapper_->setLocalPublishFallbackOption(option);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setRemoteSubscribeFallbackOption(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    STREAM_FALLBACK_OPTIONS option = STREAM_FALLBACK_OPTION_DISABLED;
    if (!reader["option"].is_null()) option = reader["option"];

    MyJson outdata;
    outdata["result"] = wrapper_->setRemoteSubscribeFallbackOption(option);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableLoopbackRecording(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    string deviceName = "";
    if (!reader["enabled"].is_null()) enabled = reader["enabled"];
    if (!reader["deviceName"].is_null()) deviceName = reader["deviceName"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableLoopbackRecording(enabled, deviceName.empty() ? nullptr : deviceName.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int adjustLoopbackSignalVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int volume = 0;
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->adjustLoopbackSignalVolume(volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getLoopbackRecordingVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getLoopbackRecordingVolume();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableInEarMonitoring(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    int includeAudioFilters = 0;
    if (!reader["enabled"].is_null()) enabled = reader["enabled"];
    if (!reader["includeAudioFilters"].is_null()) includeAudioFilters = reader["includeAudioFilters"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableInEarMonitoring(enabled, includeAudioFilters);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setInEarMonitoringVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int volume = 100;
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->setInEarMonitoringVolume(volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int loadExtensionProvider(const char *buff, size_t bufflen, std::string &out) {
#if defined(_WIN32) || defined(__linux__) || defined(__ANDROID__)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string path = "";
    bool unload_after_use = false;
    if (!reader["path"].is_null()) path = reader["path"];
    if (!reader["unload_after_use"].is_null()) unload_after_use = reader["unload_after_use"];

    MyJson outdata;
    outdata["result"] = wrapper_->loadExtensionProvider(path.c_str(), unload_after_use);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int setExtensionProviderProperty(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string provider = "";
    string key = "";
    string value = "";
    if (!reader["provider"].is_null()) provider = reader["provider"];
    if (!reader["key"].is_null()) key = reader["key"];
    if (!reader["value"].is_null()) value = reader["value"];

    MyJson outdata;
    outdata["result"] = wrapper_->setExtensionProviderProperty(
        provider.empty() ? nullptr : provider.c_str(),
        key.empty() ? nullptr : key.c_str(),
        value.empty() ? nullptr : value.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int registerExtension(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string provider = "";
    string extension = "";
    agora::media::MEDIA_SOURCE_TYPE type = agora::media::UNKNOWN_MEDIA_SOURCE;

    if (!reader["provider"].is_null()) provider = reader["provider"];
    if (!reader["extension"].is_null()) extension = reader["extension"];
    if (!reader["type"].is_null()) type = (agora::media::MEDIA_SOURCE_TYPE)reader["type"];

    MyJson outdata;
    outdata["result"] = wrapper_->registerExtension(provider.c_str(), extension.c_str(), type);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableExtension(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string provider = "";
    string extension = "";
    bool enable = true;
    agora::media::MEDIA_SOURCE_TYPE type = agora::media::UNKNOWN_MEDIA_SOURCE;

    if (!reader["provider"].is_null()) provider = reader["provider"];
    if (!reader["extension"].is_null()) extension = reader["extension"];
    if (!reader["enable"].is_null()) enable = reader["enable"];
    if (!reader["type"].is_null()) type = (agora::media::MEDIA_SOURCE_TYPE)reader["type"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableExtension(
        provider.empty() ? nullptr : provider.c_str(),
        extension.empty() ? nullptr : extension.c_str(), enable, type);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setExtensionProperty(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string provider = "";
    string extension = "";
    string key = "";
    string value = "";
    agora::media::MEDIA_SOURCE_TYPE type = agora::media::UNKNOWN_MEDIA_SOURCE;

    if (!reader["provider"].is_null()) provider = reader["provider"];
    if (!reader["extension"].is_null()) extension = reader["extension"];
    if (!reader["key"].is_null()) key = reader["key"];
    if (!reader["value"].is_null()) value = reader["value"];
    if (!reader["type"].is_null()) type = (agora::media::MEDIA_SOURCE_TYPE)(int)reader["type"];

    MyJson outdata;
    outdata["result"] = wrapper_->setExtensionProperty(
        provider.empty() ? nullptr : provider.c_str(),
        extension.empty() ? nullptr : extension.c_str(),
        key.empty() ? nullptr : key.c_str(),
        value.empty() ? nullptr : value.c_str(),
        type);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getExtensionProperty(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    std::string provider = "";
    std::string extension = "";
    std::string key = "";
    agora::media::MEDIA_SOURCE_TYPE type = agora::media::UNKNOWN_MEDIA_SOURCE;
    if (!reader["provider"].is_null()) provider = reader["provider"];
    if (!reader["extension"].is_null()) extension = reader["extension"];
    if (!reader["key"].is_null()) key = reader["key"];
    if (!reader["type"].is_null()) type = (agora::media::MEDIA_SOURCE_TYPE)reader["type"];

    char *value = new char[buf_len];
    memset(value, 0, buf_len);

    MyJson outdata;
    outdata["result"] = wrapper_->getExtensionProperty(
        provider.empty() ? nullptr : provider.c_str(),
        extension.empty() ? nullptr : extension.c_str(),
        key.empty() ? nullptr : key.c_str(), value, buf_len, type);

    outdata["value"] = value;
    out = JSON_TO_STRING(outdata);

    delete[] value;
    TRY_CATCH_END
    return 0;
}

int enableExtension(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string provider = "";
    string extension = "";
    ExtensionInfo extensionInfo;
    bool enable = true;

    if (!reader["provider"].is_null()) provider = reader["provider"];
    if (!reader["extension"].is_null()) extension = reader["extension"];

    MyJson extensionInfoReader = reader["extensionInfo"];

    if (!extensionInfoReader["mediaSourceType"].is_null())
        extensionInfo.mediaSourceType = (agora::media::MEDIA_SOURCE_TYPE) extensionInfoReader["mediaSourceType"];
    if (!extensionInfoReader["remoteUid"].is_null())
        extensionInfo.remoteUid = (uid_t)(long) extensionInfoReader["remoteUid"];
    if (!extensionInfoReader["channelId"].is_null())
        extensionInfo.channelId = extensionInfoReader["channelId"];
    if (!extensionInfoReader["localUid"].is_null())
        extensionInfo.localUid = (uid_t)(long) extensionInfoReader["localUid"];

    if (!reader["enable"].is_null()) enable = reader["enable"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableExtension(
        provider.empty() ? nullptr : provider.c_str(),
        extension.empty() ? nullptr : extension.c_str(),
        extensionInfo, enable);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setExtensionProperty(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string provider = "";
    string extension = "";
    string channelId = "";
    string key = "";
    string value = "";
    ExtensionInfo extensionInfo;

    if (!reader["provider"].is_null()) provider = reader["provider"];
    if (!reader["extension"].is_null()) extension = reader["extension"];

    MyJson extensionInfoReader = reader["extensionInfo"];
    if (!extensionInfoReader["mediaSourceType"].is_null())
        extensionInfo.mediaSourceType = (agora::media::MEDIA_SOURCE_TYPE) extensionInfoReader["mediaSourceType"];
    if (!extensionInfoReader["remoteUid"].is_null())
        extensionInfo.remoteUid = (uid_t)(long) extensionInfoReader["remoteUid"];
    if (!extensionInfoReader["channelId"].is_null()) channelId = extensionInfoReader["channelId"];
    if (!extensionInfoReader["localUid"].is_null())
        extensionInfo.localUid = (uid_t)(long) extensionInfoReader["localUid"];

    if (!reader["key"].is_null()) key = reader["key"];
    if (!reader["value"].is_null()) value = reader["value"];

    MyJson outdata;
    outdata["result"] = wrapper_->setExtensionProperty(
        provider.c_str(), extension.c_str(), extensionInfo, key.c_str(), value.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setCameraCapturerConfiguration(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    CameraCapturerConfiguration config;

#if defined(__ANDROID__) || (defined(__APPLE__) && TARGET_OS_IOS)
    if (!reader["cameraDirection"].is_null())
        config.cameraDirection = (CAMERA_DIRECTION)reader["cameraDirection"];
#else
    if (!reader["deviceId"].is_null()) {
        std::string deviceId = reader["deviceId"];
        strncpy(config.deviceId, deviceId.c_str(), MAX_DEVICE_ID_LENGTH);
    }
#endif

    if (!reader["format"].is_null()) {
        MyJson formatReader = reader["format"];
        if (!formatReader["width"].is_null()) config.format.width = formatReader["width"];
        if (!formatReader["height"].is_null()) config.format.height = formatReader["height"];
        if (!formatReader["fps"].is_null()) config.format.fps = formatReader["fps"];
        if (!formatReader["preference"].is_null()) config.format.preference = (ORIENTATION_MODE)formatReader["preference"];
    }

    if (!reader["followEncodeDimensionRatio"].is_null())
        config.followEncodeDimensionRatio = reader["followEncodeDimensionRatio"];

    MyJson outdata;
    outdata["result"] = wrapper_->setCameraCapturerConfiguration(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int createCustomVideoTrack(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->createCustomVideoTrack();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int createCustomEncodedVideoTrack(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    SenderOptions sender_option;

    MyJson senderOptionsReader = reader["sender_option"];

    if (!senderOptionsReader["ccMode"].is_null())
        sender_option.ccMode = (TCcMode)(int)senderOptionsReader["ccMode"];
    if (!senderOptionsReader["codecType"].is_null())
        sender_option.codecType = (VIDEO_CODEC_TYPE)(int)senderOptionsReader["codecType"];
    if (!senderOptionsReader["targetBitrate"].is_null())
        sender_option.targetBitrate = senderOptionsReader["targetBitrate"];

    MyJson outdata;
    outdata["result"] = wrapper_->createCustomEncodedVideoTrack(sender_option);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int destroyCustomVideoTrack(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    video_track_id_t video_track_id = (video_track_id_t)(long) reader["video_track_id"];

    MyJson outdata;
    outdata["result"] = wrapper_->destroyCustomVideoTrack(video_track_id);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int destroyCustomEncodedVideoTrack(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    video_track_id_t video_track_id = (video_track_id_t)(long) reader["video_track_id"];

    MyJson outdata;
    outdata["result"] = wrapper_->destroyCustomEncodedVideoTrack(video_track_id);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

#if defined(__ANDROID__) || (defined(__APPLE__) && TARGET_OS_IOS)
int switchCamera(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->switchCamera();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int isCameraZoomSupported(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->isCameraZoomSupported();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int isCameraFaceDetectSupported(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->isCameraFaceDetectSupported();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int isCameraTorchSupported(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->isCameraTorchSupported();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int isCameraFocusSupported(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->isCameraFocusSupported();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int isCameraAutoFocusFaceModeSupported(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->isCameraAutoFocusFaceModeSupported();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setCameraZoomFactor(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);
    float factor = reader["factor"];
    MyJson outdata;
    outdata["result"] = wrapper_->setCameraZoomFactor(factor);
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableFaceDetection(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);
    bool enabled = reader["enabled"];
    MyJson outdata;
    outdata["result"] = wrapper_->enableFaceDetection(enabled);
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getCameraMaxZoomFactor(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getCameraMaxZoomFactor();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setCameraFocusPositionInPreview(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);
    float positionX = reader["positionX"];
    float positionY = reader["positionY"];
    MyJson outdata;
    outdata["result"] = wrapper_->setCameraFocusPositionInPreview(positionX, positionY);
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setCameraTorchOn(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);
    bool isOn = reader["isOn"];
    MyJson outdata;
    outdata["result"] = wrapper_->setCameraTorchOn(isOn);
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setCameraAutoFocusFaceModeEnabled(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);
    bool enabled = reader["enabled"];
    MyJson outdata;
    outdata["result"] = wrapper_->setCameraAutoFocusFaceModeEnabled(enabled);
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int isCameraExposurePositionSupported(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->isCameraExposurePositionSupported();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setCameraExposurePosition(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);
    float positionXinView = reader["positionXinView"];
    float positionYinView = reader["positionYinView"];
    MyJson outdata;
    outdata["result"] = wrapper_->setCameraExposurePosition(positionXinView, positionYinView);
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setDefaultAudioRouteToSpeakerphone(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);
    bool defaultToSpeaker = reader["defaultToSpeaker"];
    MyJson outdata;
    outdata["result"] = wrapper_->setDefaultAudioRouteToSpeakerphone(defaultToSpeaker);
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setEnableSpeakerphone(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);
    bool speakerOn = reader["speakerOn"];
    MyJson outdata;
    outdata["result"] = wrapper_->setEnableSpeakerphone(speakerOn);
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int isSpeakerphoneEnabled(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->isSpeakerphoneEnabled();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

#if defined(__APPLE__)
int isCameraAutoExposureFaceModeSupported(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->isCameraAutoExposureFaceModeSupported();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setCameraAutoExposureFaceModeEnabled(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);
    bool enabled = reader["enabled"];
    MyJson outdata;
    outdata["result"] = wrapper_->setCameraAutoExposureFaceModeEnabled(enabled);
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}
#endif

#endif

int getScreenCaptureSources(const char *buff, size_t bufflen, std::string &out) {
#if defined(_WIN32) || (defined(__APPLE__) && TARGET_OS_MAC && !TARGET_OS_IPHONE)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    SIZE thumbSize;
    SIZE iconSize;
    bool includeScreen = false;

    MyJson thumbSizeReader = reader["thumbSize"];
    MyJson iconSizeReader = reader["iconSize"];

    if (!thumbSizeReader["width"].is_null()) thumbSize.width = thumbSizeReader["width"];
    if (!thumbSizeReader["height"].is_null()) thumbSize.height = thumbSizeReader["height"];
    if (!iconSizeReader["width"].is_null()) iconSize.width = iconSizeReader["width"];
    if (!iconSizeReader["height"].is_null()) iconSize.height = iconSizeReader["height"];
    if (!reader["includeScreen"].is_null()) includeScreen = reader["includeScreen"];

    MyJson outdata;
    outdata["result"] = (long long) wrapper_->getScreenCaptureSources(thumbSize, iconSize, includeScreen);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int setAudioSessionOperationRestriction(const char *buff, size_t bufflen, std::string &out) {
#if (defined(__APPLE__) && TARGET_OS_IOS)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);
    AUDIO_SESSION_OPERATION_RESTRICTION restriction = reader["restriction"];
    MyJson outdata;
    outdata["result"] = wrapper_->setAudioSessionOperationRestriction(restriction);
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int startScreenCaptureByDisplayId(const char *buff, size_t bufflen, std::string &out) {
#if defined(_WIN32) || (defined(__APPLE__) && !TARGET_OS_IPHONE && TARGET_OS_MAC)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    uint32_t displayId = reader["displayId"];

    MyJson regionRectReader = reader["regionRect"];
    Rectangle regionRect;
    if (!regionRectReader["x"].is_null()) regionRect.x = regionRectReader["x"];
    if (!regionRectReader["y"].is_null()) regionRect.y = regionRectReader["y"];
    if (!regionRectReader["width"].is_null()) regionRect.width = regionRectReader["width"];
    if (!regionRectReader["height"].is_null()) regionRect.height = regionRectReader["height"];

    MyJson captureParamsReader = reader["captureParams"];
    ScreenCaptureParameters captureParams;
    MyJson dimensionsReader = captureParamsReader["dimensions"];
    if (!dimensionsReader["width"].is_null()) captureParams.dimensions.width = dimensionsReader["width"];
    if (!dimensionsReader["height"].is_null()) captureParams.dimensions.height = dimensionsReader["height"];
    if (!captureParamsReader["frameRate"].is_null()) captureParams.frameRate = captureParamsReader["frameRate"];
    if (!captureParamsReader["bitrate"].is_null()) captureParams.bitrate = captureParamsReader["bitrate"];
    if (!captureParamsReader["captureMouseCursor"].is_null()) captureParams.captureMouseCursor = captureParamsReader["captureMouseCursor"];
    if (!captureParamsReader["windowFocus"].is_null()) captureParams.windowFocus = captureParamsReader["windowFocus"];
    if (!captureParamsReader["excludeWindowList"].is_null()) captureParams.excludeWindowList = (view_t*)captureParamsReader["excludeWindowList"];
    if (!captureParamsReader["excludeWindowCount"].is_null()) captureParams.excludeWindowCount = captureParamsReader["excludeWindowCount"];
    if (!captureParamsReader["highLightWidth"].is_null()) captureParams.highLightWidth = captureParamsReader["highLightWidth"];
    if (!captureParamsReader["highLightColor"].is_null()) captureParams.highLightColor = captureParamsReader["highLightColor"];
    if (!captureParamsReader["enableHighLight"].is_null()) captureParams.enableHighLight = captureParamsReader["enableHighLight"];

    MyJson outdata;
    outdata["result"] = wrapper_->startScreenCaptureByDisplayId(displayId, regionRect, captureParams);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int startScreenCaptureByScreenRect(const char *buff, size_t bufflen, std::string &out) {
#if defined(_WIN32)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    Rectangle screenRect;
    Rectangle regionRect;
    ScreenCaptureParameters captureParams;

    MyJson screenRectReader = reader["screenRect"];
    MyJson regionRectReader = reader["regionRect"];
    MyJson captureParamsReader = reader["captureParams"];

    if (!screenRectReader["x"].is_null()) screenRect.x = screenRectReader["x"];
    if (!screenRectReader["y"].is_null()) screenRect.y = screenRectReader["y"];
    if (!screenRectReader["width"].is_null()) screenRect.width = screenRectReader["width"];
    if (!screenRectReader["height"].is_null()) screenRect.height = screenRectReader["height"];

    if (!regionRectReader["x"].is_null()) regionRect.x = regionRectReader["x"];
    if (!regionRectReader["y"].is_null()) regionRect.y = regionRectReader["y"];
    if (!regionRectReader["width"].is_null()) regionRect.width = regionRectReader["width"];
    if (!regionRectReader["height"].is_null()) regionRect.height = regionRectReader["height"];

    if (!captureParamsReader["dimensions"].is_null()) {
        MyJson dimensionsReader = captureParamsReader["dimensions"];
        if (!dimensionsReader["width"].is_null()) captureParams.dimensions.width = dimensionsReader["width"];
        if (!dimensionsReader["height"].is_null()) captureParams.dimensions.height = dimensionsReader["height"];
    }

    if (!captureParamsReader["frameRate"].is_null()) captureParams.frameRate = captureParamsReader["frameRate"];
    if (!captureParamsReader["bitrate"].is_null()) captureParams.bitrate = captureParamsReader["bitrate"];
    if (!captureParamsReader["captureMouseCursor"].is_null())
        captureParams.captureMouseCursor = captureParamsReader["captureMouseCursor"];
    if (!captureParamsReader["windowFocus"].is_null()) captureParams.windowFocus = captureParamsReader["windowFocus"];
    if (!captureParamsReader["excludeWindowList"].is_null()) {
        view_t *excludeWindowList = nullptr;
        MyJson excludeWindowListReader = captureParamsReader["excludeWindowList"];
        if (excludeWindowListReader.is_array()) {
            excludeWindowList = new view_t[excludeWindowListReader.size()];
            for (int i = 0; i < excludeWindowListReader.size(); i++) {
                excludeWindowList[i] = (view_t)(long) excludeWindowListReader[i];
            }
        }
        captureParams.excludeWindowList = excludeWindowList;
    }
    if (!captureParamsReader["excludeWindowCount"].is_null())
        captureParams.excludeWindowCount = captureParamsReader["excludeWindowCount"];
    if (!captureParamsReader["highLightWidth"].is_null())
        captureParams.highLightWidth = captureParamsReader["highLightWidth"];
    if (!captureParamsReader["highLightColor"].is_null())
        captureParams.highLightColor = captureParamsReader["highLightColor"];
    if (!captureParamsReader["enableHighLight"].is_null())
        captureParams.enableHighLight = captureParamsReader["enableHighLight"];

    MyJson outdata;
    outdata["result"] = wrapper_->startScreenCaptureByScreenRect(screenRect, regionRect, captureParams);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int getAudioDeviceInfo(const char *buff, size_t bufflen, std::string &out) {
#if defined(__ANDROID__)
    TRY_CATCH_START
    MyJson outdata;
    DeviceInfo deviceInfo;
    wrapper_->getAudioDeviceInfo(deviceInfo);
    outdata["result"]["isLowLatencyAudioSupported"] = deviceInfo.isLowLatencyAudioSupported;
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int startScreenCaptureByWindowId(const char *buff, size_t bufflen, std::string &out) {
#if defined(_WIN32) || (defined(__APPLE__) && TARGET_OS_MAC && !TARGET_OS_IPHONE)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    view_t windowId = reader["windowId"];
    Rectangle regionRect;
    ScreenCaptureParameters captureParams;

    MyJson regionRectReader = reader["regionRect"];
    if (!regionRectReader["x"].is_null()) regionRect.x = regionRectReader["x"];
    if (!regionRectReader["y"].is_null()) regionRect.y = regionRectReader["y"];
    if (!regionRectReader["width"].is_null()) regionRect.width = regionRectReader["width"];
    if (!regionRectReader["height"].is_null()) regionRect.height = regionRectReader["height"];

    MyJson captureParamsReader = reader["captureParams"];
    if (!captureParamsReader["dimensions"].is_null()) {
        MyJson dimensionsReader = captureParamsReader["dimensions"];
        if (!dimensionsReader["width"].is_null()) captureParams.dimensions.width = dimensionsReader["width"];
        if (!dimensionsReader["height"].is_null()) captureParams.dimensions.height = dimensionsReader["height"];
    }
    if (!captureParamsReader["frameRate"].is_null()) captureParams.frameRate = captureParamsReader["frameRate"];
    if (!captureParamsReader["bitrate"].is_null()) captureParams.bitrate = captureParamsReader["bitrate"];
    if (!captureParamsReader["captureMouseCursor"].is_null())
        captureParams.captureMouseCursor = captureParamsReader["captureMouseCursor"];
    if (!captureParamsReader["windowFocus"].is_null()) captureParams.windowFocus = captureParamsReader["windowFocus"];
    if (!captureParamsReader["excludeWindowList"].is_null()) {
        // TODO: handle excludeWindowList
    }
    if (!captureParamsReader["excludeWindowCount"].is_null())
        captureParams.excludeWindowCount = captureParamsReader["excludeWindowCount"];
    if (!captureParamsReader["highLightWidth"].is_null())
        captureParams.highLightWidth = captureParamsReader["highLightWidth"];
    if (!captureParamsReader["highLightColor"].is_null())
        captureParams.highLightColor = captureParamsReader["highLightColor"];
    if (!captureParamsReader["enableHighLight"].is_null())
        captureParams.enableHighLight = captureParamsReader["enableHighLight"];

    MyJson outdata;
    outdata["result"] = wrapper_->startScreenCaptureByWindowId(windowId, regionRect, captureParams);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int setScreenCaptureContentHint(const char *buff, size_t bufflen, std::string &out) {
#if defined(_WIN32) || (defined(__APPLE__) && TARGET_OS_MAC && !TARGET_OS_IPHONE)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VIDEO_CONTENT_HINT contentHint = CONTENT_HINT_NONE;
    if (!reader["contentHint"].is_null()) contentHint = reader["contentHint"];

    MyJson outdata;
    outdata["result"] = wrapper_->setScreenCaptureContentHint(contentHint);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int setScreenCaptureScenario(const char *buff, size_t bufflen, std::string &out) {
#if defined(_WIN32) || (defined(__APPLE__) && TARGET_OS_MAC && !TARGET_OS_IPHONE)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    SCREEN_SCENARIO_TYPE screenScenario = SCREEN_SCENARIO_DOCUMENT;
    if (!reader["screenScenario"].is_null()) screenScenario = reader["screenScenario"];

    MyJson outdata;
    outdata["result"] = wrapper_->setScreenCaptureScenario(screenScenario);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int updateScreenCaptureRegion(const char *buff, size_t bufflen, std::string &out) {
#if defined(_WIN32) || (defined(__APPLE__) && TARGET_OS_MAC && !TARGET_OS_IPHONE)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    Rectangle regionRect;
    if (!reader["regionRect"].is_null()) {
        MyJson regionRectReader = reader["regionRect"];
        if (!regionRectReader["x"].is_null()) regionRect.x = regionRectReader["x"];
        if (!regionRectReader["y"].is_null()) regionRect.y = regionRectReader["y"];
        if (!regionRectReader["width"].is_null()) regionRect.width = regionRectReader["width"];
        if (!regionRectReader["height"].is_null()) regionRect.height = regionRectReader["height"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->updateScreenCaptureRegion(regionRect);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int updateScreenCaptureParameters(const char *buff, size_t bufflen, std::string &out) {
#if defined(_WIN32) || (defined(__APPLE__) && TARGET_OS_MAC && !TARGET_OS_IPHONE)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    ScreenCaptureParameters captureParams;

    if (!reader["dimensions"].is_null()) {
        MyJson dimensionsReader = reader["dimensions"];
        if (!dimensionsReader["width"].is_null()) captureParams.dimensions.width = dimensionsReader["width"];
        if (!dimensionsReader["height"].is_null()) captureParams.dimensions.height = dimensionsReader["height"];
    }
    if (!reader["frameRate"].is_null()) captureParams.frameRate = reader["frameRate"];
    if (!reader["bitrate"].is_null()) captureParams.bitrate = reader["bitrate"];
    if (!reader["captureMouseCursor"].is_null())
        captureParams.captureMouseCursor = reader["captureMouseCursor"];
    if (!reader["windowFocus"].is_null()) captureParams.windowFocus = reader["windowFocus"];
    if (!reader["excludeWindowList"].is_null()) {
        // TODO: handle excludeWindowList
    }
    if (!reader["excludeWindowCount"].is_null())
        captureParams.excludeWindowCount = reader["excludeWindowCount"];
    if (!reader["highLightWidth"].is_null())
        captureParams.highLightWidth = reader["highLightWidth"];
    if (!reader["highLightColor"].is_null())
        captureParams.highLightColor = reader["highLightColor"];
    if (!reader["enableHighLight"].is_null())
        captureParams.enableHighLight = reader["enableHighLight"];

    MyJson outdata;
    outdata["result"] = wrapper_->updateScreenCaptureParameters(captureParams);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int startScreenCapture(const char *buff, size_t bufflen, std::string &out) {
#if defined(__ANDROID__) || (defined(__APPLE__) && TARGET_OS_IOS)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    ScreenCaptureParameters2 captureParams;

    MyJson screenCaptureParamsReader = reader["captureParams"];

    if (!screenCaptureParamsReader["captureAudio"].is_null())
        captureParams.captureAudio = screenCaptureParamsReader["captureAudio"];
    if (!screenCaptureParamsReader["audioParams"].is_null()) {
        MyJson audioParamsReader = screenCaptureParamsReader["audioParams"];
        if (!audioParamsReader["sampleRate"].is_null())
            captureParams.audioParams.sampleRate = audioParamsReader["sampleRate"];
        if (!audioParamsReader["channelCount"].is_null())
            captureParams.audioParams.channelCount = audioParamsReader["channelCount"];
        if (!audioParamsReader["profile"].is_null())
            captureParams.audioParams.profile = audioParamsReader["profile"];
    }
    if (!screenCaptureParamsReader["captureVideo"].is_null())
        captureParams.captureVideo = screenCaptureParamsReader["captureVideo"];
    if (!screenCaptureParamsReader["videoParams"].is_null()) {
        MyJson videoParamsReader = screenCaptureParamsReader["videoParams"];
        if (!videoParamsReader["dimensions"].is_null()) {
            MyJson dimensionsReader = videoParamsReader["dimensions"];
            if (!dimensionsReader["width"].is_null())
                captureParams.videoParams.dimensions.width = dimensionsReader["width"];
            if (!dimensionsReader["height"].is_null())
                captureParams.videoParams.dimensions.height = dimensionsReader["height"];
        }
        if (!videoParamsReader["frameRate"].is_null())
            captureParams.videoParams.frameRate = videoParamsReader["frameRate"];
        if (!videoParamsReader["bitrate"].is_null())
            captureParams.videoParams.bitrate = videoParamsReader["bitrate"];
        if (!videoParamsReader["captureMouseCursor"].is_null())
            captureParams.videoParams.captureMouseCursor = videoParamsReader["captureMouseCursor"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->startScreenCapture(captureParams);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int updateScreenCapture(const char *buff, size_t bufflen, std::string &out) {
#if defined(__ANDROID__) || (defined(__APPLE__) && TARGET_OS_IOS)
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    ScreenCaptureParameters2 captureParams;

    MyJson screenCaptureParamsReader = reader["captureParams"];

    if (!screenCaptureParamsReader["captureAudio"].is_null())
        captureParams.captureAudio = screenCaptureParamsReader["captureAudio"];
    if (!screenCaptureParamsReader["audioParams"].is_null()) {
        MyJson audioParamsReader = screenCaptureParamsReader["audioParams"];
        if (!audioParamsReader["sampleRate"].is_null())
            captureParams.audioParams.sampleRate = audioParamsReader["sampleRate"];
        if (!audioParamsReader["channelCount"].is_null())
            captureParams.audioParams.channelCount = audioParamsReader["channelCount"];
        if (!audioParamsReader["profile"].is_null())
            captureParams.audioParams.profile = audioParamsReader["profile"];
    }
    if (!screenCaptureParamsReader["captureVideo"].is_null())
        captureParams.captureVideo = screenCaptureParamsReader["captureVideo"];
    if (!screenCaptureParamsReader["videoParams"].is_null()) {
        MyJson videoParamsReader = screenCaptureParamsReader["videoParams"];
        if (!videoParamsReader["dimensions"].is_null()) {
            MyJson dimensionsReader = videoParamsReader["dimensions"];
            if (!dimensionsReader["width"].is_null())
                captureParams.videoParams.dimensions.width = dimensionsReader["width"];
            if (!dimensionsReader["height"].is_null())
                captureParams.videoParams.dimensions.height = dimensionsReader["height"];
        }
        if (!videoParamsReader["frameRate"].is_null())
            captureParams.videoParams.frameRate = videoParamsReader["frameRate"];
        if (!videoParamsReader["bitrate"].is_null())
            captureParams.videoParams.bitrate = videoParamsReader["bitrate"];
        if (!videoParamsReader["captureMouseCursor"].is_null())
            captureParams.videoParams.captureMouseCursor = videoParamsReader["captureMouseCursor"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->updateScreenCapture(captureParams);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int stopScreenCapture(const char *buff, size_t bufflen, std::string &out) {
#if defined(_WIN32) || defined(__APPLE__) || defined(__ANDROID__)
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopScreenCapture();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
#else
    return -ERROR_CODE_TYPE::ERR_NOT_SUPPORTED;
#endif
}

int getCallId(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    agora::util::AString callId;
    MyJson outdata;
    outdata["result"] = wrapper_->getCallId(callId);
    outdata["callId"] = callId->c_str();
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int rate(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string callId = "";
    int rating = 0;
    string description = "";
    if (!reader["callId"].is_null()) callId = reader["callId"];
    if (!reader["rating"].is_null()) rating = reader["rating"];
    if (!reader["description"].is_null()) description = reader["description"];

    MyJson outdata;
    outdata["result"] = wrapper_->rate(
        callId.empty() ? nullptr : callId.c_str(), rating,
        description.empty() ? nullptr : description.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int complain(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string callId = "";
    string description = "";
    if (!reader["callId"].is_null()) callId = reader["callId"];
    if (!reader["description"].is_null()) description = reader["description"];

    MyJson outdata;
    outdata["result"] = wrapper_->complain(
        callId.empty() ? nullptr : callId.c_str(),
        description.empty() ? nullptr : description.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startRtmpStreamWithoutTranscoding(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string url = "";
    if (!reader["url"].is_null()) url = reader["url"];

    MyJson outdata;
    outdata["result"] = wrapper_->startRtmpStreamWithoutTranscoding(url.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startRtmpStreamWithTranscoding(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string url = "";
    if (!reader["url"].is_null()) url = reader["url"];

    LiveTranscoding transcoding;
    MyJson transcodingReader = reader["transcoding"];

    if (!transcodingReader["width"].is_null())
        transcoding.width = transcodingReader["width"];
    if (!transcodingReader["height"].is_null())
        transcoding.height = transcodingReader["height"];
    if (!transcodingReader["videoBitrate"].is_null())
        transcoding.videoBitrate = transcodingReader["videoBitrate"];
    if (!transcodingReader["videoFramerate"].is_null())
        transcoding.videoFramerate = transcodingReader["videoFramerate"];
    if (!transcodingReader["lowLatency"].is_null())
        transcoding.lowLatency = transcodingReader["lowLatency"];
    if (!transcodingReader["videoGop"].is_null())
        transcoding.videoGop = transcodingReader["videoGop"];
    if (!transcodingReader["videoCodecProfile"].is_null())
        transcoding.videoCodecProfile = transcodingReader["videoCodecProfile"];
    if (!transcodingReader["backgroundColor"].is_null())
        transcoding.backgroundColor = transcodingReader["backgroundColor"];
    if (!transcodingReader["videoCodecType"].is_null())
        transcoding.videoCodecType = transcodingReader["videoCodecType"];
    if (!transcodingReader["userCount"].is_null())
        transcoding.userCount = transcodingReader["userCount"];
    if (!transcodingReader["transcodingUsers"].is_null()) {
        MyJson transcodingUsersReader = transcodingReader["transcodingUsers"];
        transcoding.transcodingUsers = new TranscodingUser[transcoding.userCount];
        for (int i = 0; i < transcoding.userCount; i++) {
            MyJson transcodingUserReader = transcodingUsersReader[i];
            if (!transcodingUserReader["uid"].is_null())
                transcoding.transcodingUsers[i].uid = (uid_t)(long) transcodingUserReader["uid"];
            if (!transcodingUserReader["x"].is_null())
                transcoding.transcodingUsers[i].x = transcodingUserReader["x"];
            if (!transcodingUserReader["y"].is_null())
                transcoding.transcodingUsers[i].y = transcodingUserReader["y"];
            if (!transcodingUserReader["width"].is_null())
                transcoding.transcodingUsers[i].width = transcodingUserReader["width"];
            if (!transcodingUserReader["height"].is_null())
                transcoding.transcodingUsers[i].height = transcodingUserReader["height"];
            if (!transcodingUserReader["zOrder"].is_null())
                transcoding.transcodingUsers[i].zOrder = transcodingUserReader["zOrder"];
            if (!transcodingUserReader["alpha"].is_null())
                transcoding.transcodingUsers[i].alpha = transcodingUserReader["alpha"];
            if (!transcodingUserReader["audioChannel"].is_null())
                transcoding.transcodingUsers[i].audioChannel = transcodingUserReader["audioChannel"];
        }
    }
    if (!transcodingReader["transcodingExtraInfo"].is_null())
        transcoding.transcodingExtraInfo = transcodingReader["transcodingExtraInfo"];
    if (!transcodingReader["metadata"].is_null())
        transcoding.metadata = transcodingReader["metadata"];
    if (!transcodingReader["watermark"].is_null()) {
        MyJson watermarkReader = transcodingReader["watermark"];
        transcoding.watermark = new RtcImage;
        if (!watermarkReader["url"].is_null())
            transcoding.watermark->url = watermarkReader["url"];
        if (!watermarkReader["x"].is_null())
            transcoding.watermark->x = watermarkReader["x"];
        if (!watermarkReader["y"].is_null())
            transcoding.watermark->y = watermarkReader["y"];
        if (!watermarkReader["width"].is_null())
            transcoding.watermark->width = watermarkReader["width"];
        if (!watermarkReader["height"].is_null())
            transcoding.watermark->height = watermarkReader["height"];
    }
    if (!transcodingReader["watermarkCount"].is_null())
        transcoding.watermarkCount = transcodingReader["watermarkCount"];
    if (!transcodingReader["backgroundImage"].is_null()) {
        MyJson backgroundImageReader = transcodingReader["backgroundImage"];
        transcoding.backgroundImage = new RtcImage;
        if (!backgroundImageReader["url"].is_null())
            transcoding.backgroundImage->url = backgroundImageReader["url"];
        if (!backgroundImageReader["x"].is_null())
            transcoding.backgroundImage->x = backgroundImageReader["x"];
        if (!backgroundImageReader["y"].is_null())
            transcoding.backgroundImage->y = backgroundImageReader["y"];
        if (!backgroundImageReader["width"].is_null())
            transcoding.backgroundImage->width = backgroundImageReader["width"];
        if (!backgroundImageReader["height"].is_null())
            transcoding.backgroundImage->height = backgroundImageReader["height"];
    }
    if (!transcodingReader["backgroundImageCount"].is_null())
        transcoding.backgroundImageCount = transcodingReader["backgroundImageCount"];
    if (!transcodingReader["audioSampleRate"].is_null())
        transcoding.audioSampleRate = transcodingReader["audioSampleRate"];
    if (!transcodingReader["audioBitrate"].is_null())
        transcoding.audioBitrate = transcodingReader["audioBitrate"];
    if (!transcodingReader["audioChannels"].is_null())
        transcoding.audioChannels = transcodingReader["audioChannels"];
    if (!transcodingReader["audioCodecProfile"].is_null())
        transcoding.audioCodecProfile = transcodingReader["audioCodecProfile"];
    if (!transcodingReader["advancedFeatures"].is_null()) {
        MyJson advancedFeaturesReader = transcodingReader["advancedFeatures"];
        transcoding.advancedFeatureCount = advancedFeaturesReader.size();
        transcoding.advancedFeatures = new LiveStreamAdvancedFeature[transcoding.advancedFeatureCount];
        for (int i = 0; i < transcoding.advancedFeatureCount; i++) {
            MyJson advancedFeatureReader = advancedFeaturesReader[i];
            if (!advancedFeatureReader["featureName"].is_null())
                transcoding.advancedFeatures[i].featureName = advancedFeatureReader["featureName"];
            if (!advancedFeatureReader["open"].is_null())
                transcoding.advancedFeatures[i].open = advancedFeatureReader["open"];
        }
    }

    MyJson outdata;
    outdata["result"] = wrapper_->startRtmpStreamWithTranscoding(
        url.c_str(), transcoding);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int updateRtmpTranscoding(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    LiveTranscoding transcoding;

    if (!reader["width"].is_null()) transcoding.width = reader["width"];
    if (!reader["height"].is_null()) transcoding.height = reader["height"];
    if (!reader["videoBitrate"].is_null()) transcoding.videoBitrate = reader["videoBitrate"];
    if (!reader["videoFramerate"].is_null()) transcoding.videoFramerate = reader["videoFramerate"];
    if (!reader["lowLatency"].is_null()) transcoding.lowLatency = reader["lowLatency"];
    if (!reader["videoGop"].is_null()) transcoding.videoGop = reader["videoGop"];
    if (!reader["videoCodecProfile"].is_null()) transcoding.videoCodecProfile = reader["videoCodecProfile"];
    if (!reader["backgroundColor"].is_null()) transcoding.backgroundColor = reader["backgroundColor"];
    if (!reader["videoCodecType"].is_null()) transcoding.videoCodecType = reader["videoCodecType"];
    if (!reader["userCount"].is_null()) transcoding.userCount = reader["userCount"];
    if (!reader["transcodingUsers"].is_null()) {
        MyJson transcodingUsersReader = reader["transcodingUsers"];
        transcoding.transcodingUsers = new TranscodingUser[transcoding.userCount];
        for (int i = 0; i < transcoding.userCount; i++) {
            MyJson transcodingUserReader = transcodingUsersReader[i];
            if (!transcodingUserReader["uid"].is_null()) transcoding.transcodingUsers[i].uid = (uid_t)(long) transcodingUserReader["uid"];
            if (!transcodingUserReader["x"].is_null()) transcoding.transcodingUsers[i].x = transcodingUserReader["x"];
            if (!transcodingUserReader["y"].is_null()) transcoding.transcodingUsers[i].y = transcodingUserReader["y"];
            if (!transcodingUserReader["width"].is_null()) transcoding.transcodingUsers[i].width = transcodingUserReader["width"];
            if (!transcodingUserReader["height"].is_null()) transcoding.transcodingUsers[i].height = transcodingUserReader["height"];
            if (!transcodingUserReader["zOrder"].is_null()) transcoding.transcodingUsers[i].zOrder = transcodingUserReader["zOrder"];
            if (!transcodingUserReader["alpha"].is_null()) transcoding.transcodingUsers[i].alpha = transcodingUserReader["alpha"];
            if (!transcodingUserReader["audioChannel"].is_null()) transcoding.transcodingUsers[i].audioChannel = transcodingUserReader["audioChannel"];
        }
    }
    if (!reader["transcodingExtraInfo"].is_null()) transcoding.transcodingExtraInfo = reader["transcodingExtraInfo"];
    if (!reader["metadata"].is_null()) transcoding.metadata = reader["metadata"];
    if (!reader["watermark"].is_null()) {
        MyJson watermarkReader = reader["watermark"];
        transcoding.watermarkCount = watermarkReader.size();
        transcoding.watermark = new RtcImage[transcoding.watermarkCount];
        for (int i = 0; i < transcoding.watermarkCount; i++) {
            MyJson watermarkItemReader = watermarkReader[i];
            if (!watermarkItemReader["url"].is_null()) transcoding.watermark[i].url = watermarkItemReader["url"];
            if (!watermarkItemReader["x"].is_null()) transcoding.watermark[i].x = watermarkItemReader["x"];
            if (!watermarkItemReader["y"].is_null()) transcoding.watermark[i].y = watermarkItemReader["y"];
            if (!watermarkItemReader["width"].is_null()) transcoding.watermark[i].width = watermarkItemReader["width"];
            if (!watermarkItemReader["height"].is_null()) transcoding.watermark[i].height = watermarkItemReader["height"];
        }
    }
    if (!reader["backgroundImage"].is_null()) {
        MyJson backgroundImageReader = reader["backgroundImage"];
        transcoding.backgroundImageCount = backgroundImageReader.size();
        transcoding.backgroundImage = new RtcImage[transcoding.backgroundImageCount];
        for (int i = 0; i < transcoding.backgroundImageCount; i++) {
            MyJson backgroundImageItemReader = backgroundImageReader[i];
            if (!backgroundImageItemReader["url"].is_null()) transcoding.backgroundImage[i].url = backgroundImageItemReader["url"];
            if (!backgroundImageItemReader["x"].is_null()) transcoding.backgroundImage[i].x = backgroundImageItemReader["x"];
            if (!backgroundImageItemReader["y"].is_null()) transcoding.backgroundImage[i].y = backgroundImageItemReader["y"];
            if (!backgroundImageItemReader["width"].is_null()) transcoding.backgroundImage[i].width = backgroundImageItemReader["width"];
            if (!backgroundImageItemReader["height"].is_null()) transcoding.backgroundImage[i].height = backgroundImageItemReader["height"];
        }
    }
    if (!reader["audioSampleRate"].is_null()) transcoding.audioSampleRate = reader["audioSampleRate"];
    if (!reader["audioBitrate"].is_null()) transcoding.audioBitrate = reader["audioBitrate"];
    if (!reader["audioChannels"].is_null()) transcoding.audioChannels = reader["audioChannels"];
    if (!reader["audioCodecProfile"].is_null()) transcoding.audioCodecProfile = reader["audioCodecProfile"];
    if (!reader["advancedFeatures"].is_null()) {
        MyJson advancedFeaturesReader = reader["advancedFeatures"];
        transcoding.advancedFeatureCount = advancedFeaturesReader.size();
        transcoding.advancedFeatures = new LiveStreamAdvancedFeature[transcoding.advancedFeatureCount];
        for (int i = 0; i < transcoding.advancedFeatureCount; i++) {
            MyJson advancedFeatureReader = advancedFeaturesReader[i];
            if (!advancedFeatureReader["featureName"].is_null()) transcoding.advancedFeatures[i].featureName = advancedFeatureReader["featureName"];
            if (!advancedFeatureReader["open"].is_null()) transcoding.advancedFeatures[i].open = advancedFeatureReader["open"];
        }
    }

    MyJson outdata;
    outdata["result"] = wrapper_->updateRtmpTranscoding(transcoding);

    if (transcoding.transcodingUsers != nullptr) delete[] transcoding.transcodingUsers;
    if (transcoding.watermark != nullptr) delete[] transcoding.watermark;
    if (transcoding.backgroundImage != nullptr) delete[] transcoding.backgroundImage;
    if (transcoding.advancedFeatures != nullptr) delete[] transcoding.advancedFeatures;

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopRtmpStream(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string url = "";
    if (!reader["url"].is_null()) url = reader["url"];

    MyJson outdata;
    outdata["result"] = wrapper_->stopRtmpStream(url.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startLocalVideoTranscoder(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    LocalTranscoderConfiguration config;
    MyJson localTranscoderConfigReader = reader["config"];

    if (!localTranscoderConfigReader["streamCount"].is_null())
        config.streamCount = localTranscoderConfigReader["streamCount"];

    if (!localTranscoderConfigReader["VideoInputStreams"].is_null()) {
        MyJson videoInputStreamsReader = localTranscoderConfigReader["VideoInputStreams"];
        config.VideoInputStreams = new TranscodingVideoStream[config.streamCount];
        for (int i = 0; i < config.streamCount; i++) {
            MyJson videoInputStreamReader = videoInputStreamsReader[i];
            if (!videoInputStreamReader["uid"].is_null())
                config.VideoInputStreams[i].uid = (uid_t)(long) videoInputStreamReader["uid"];
            if (!videoInputStreamReader["x"].is_null())
                config.VideoInputStreams[i].x = videoInputStreamReader["x"];
            if (!videoInputStreamReader["y"].is_null())
                config.VideoInputStreams[i].y = videoInputStreamReader["y"];
            if (!videoInputStreamReader["width"].is_null())
                config.VideoInputStreams[i].width = videoInputStreamReader["width"];
            if (!videoInputStreamReader["height"].is_null())
                config.VideoInputStreams[i].height = videoInputStreamReader["height"];
            if (!videoInputStreamReader["zOrder"].is_null())
                config.VideoInputStreams[i].zOrder = videoInputStreamReader["zOrder"];
            if (!videoInputStreamReader["alpha"].is_null())
                config.VideoInputStreams[i].alpha = videoInputStreamReader["alpha"];
            if (!videoInputStreamReader["audioChannel"].is_null())
                config.VideoInputStreams[i].audioChannel = videoInputStreamReader["audioChannel"];
        }
    }

    if (!localTranscoderConfigReader["videoOutputConfiguration"].is_null()) {
        MyJson videoOutputConfigurationReader = localTranscoderConfigReader["videoOutputConfiguration"];
        if (!videoOutputConfigurationReader["width"].is_null())
            config.videoOutputConfiguration.dimensions.width = videoOutputConfigurationReader["width"];
        if (!videoOutputConfigurationReader["height"].is_null())
            config.videoOutputConfiguration.dimensions.height = videoOutputConfigurationReader["height"];
        if (!videoOutputConfigurationReader["frameRate"].is_null())
            config.videoOutputConfiguration.frameRate = (FRAME_RATE)videoOutputConfigurationReader["frameRate"];
        if (!videoOutputConfigurationReader["minFrameRate"].is_null())
            config.videoOutputConfiguration.minFrameRate = (FRAME_RATE)videoOutputConfigurationReader["minFrameRate"];
        if (!videoOutputConfigurationReader["bitrate"].is_null())
            config.videoOutputConfiguration.bitrate = videoOutputConfigurationReader["bitrate"];
        if (!videoOutputConfigurationReader["minBitrate"].is_null())
            config.videoOutputConfiguration.minBitrate = videoOutputConfigurationReader["minBitrate"];
        if (!videoOutputConfigurationReader["orientationMode"].is_null())
            config.videoOutputConfiguration.orientationMode = (ORIENTATION_MODE)videoOutputConfigurationReader["orientationMode"];
        if (!videoOutputConfigurationReader["degradationPreference"].is_null())
            config.videoOutputConfiguration.degradationPreference = (DEGRADATION_PREFERENCE)videoOutputConfigurationReader["degradationPreference"];
        if (!videoOutputConfigurationReader["mirrorMode"].is_null())
            config.videoOutputConfiguration.mirrorMode = (VIDEO_MIRROR_MODE_TYPE)videoOutputConfigurationReader["mirrorMode"];
    }

    if (!localTranscoderConfigReader["syncWithPrimaryCamera"].is_null())
        config.syncWithPrimaryCamera = localTranscoderConfigReader["syncWithPrimaryCamera"];

    MyJson outdata;
    outdata["result"] = wrapper_->startLocalVideoTranscoder(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopLocalVideoTranscoder(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopLocalVideoTranscoder();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startPrimaryCameraCapture(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    CameraCapturerConfiguration config;

    MyJson cameraCapturerConfigReader = reader["config"];

#if defined(__ANDROID__) || (defined(__APPLE__) && TARGET_OS_IOS)
    if (!cameraCapturerConfigReader["cameraDirection"].is_null())
        config.cameraDirection = (CAMERA_DIRECTION)cameraCapturerConfigReader["cameraDirection"];
#else
    if (!cameraCapturerConfigReader["deviceId"].is_null())
        strncpy(config.deviceId, cameraCapturerConfigReader["deviceId"].get<std::string>().c_str(), MAX_DEVICE_ID_LENGTH);
#endif

    if (!cameraCapturerConfigReader["format"].is_null()) {
        MyJson formatReader = cameraCapturerConfigReader["format"];
        VideoFormat format;
        if (!formatReader["width"].is_null()) format.width = formatReader["width"];
        if (!formatReader["height"].is_null()) format.height = formatReader["height"];
        if (!formatReader["fps"].is_null()) format.fps = formatReader["fps"];
        if (!formatReader["preference"].is_null()) format.preference = (ORIENTATION_MODE)formatReader["preference"];
        config.format = format;
    }

    if (!cameraCapturerConfigReader["followEncodeDimensionRatio"].is_null())
        config.followEncodeDimensionRatio = cameraCapturerConfigReader["followEncodeDimensionRatio"];

    MyJson outdata;
    outdata["result"] = wrapper_->startPrimaryCameraCapture(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startSecondaryCameraCapture(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    CameraCapturerConfiguration config;

    MyJson cameraCapturerConfigReader = reader["config"];

#if defined(__ANDROID__) || (defined(__APPLE__) && TARGET_OS_IOS)
    if (!cameraCapturerConfigReader["cameraDirection"].is_null())
        config.cameraDirection = (CAMERA_DIRECTION)cameraCapturerConfigReader["cameraDirection"];
#else
    if (!cameraCapturerConfigReader["deviceId"].is_null())
        strncpy(config.deviceId, cameraCapturerConfigReader["deviceId"].get<std::string>().c_str(), MAX_DEVICE_ID_LENGTH);
#endif

    if (!cameraCapturerConfigReader["format"].is_null()) {
        MyJson formatReader = cameraCapturerConfigReader["format"];
        VideoFormat format;
        if (!formatReader["width"].is_null()) format.width = formatReader["width"];
        if (!formatReader["height"].is_null()) format.height = formatReader["height"];
        if (!formatReader["fps"].is_null()) format.fps = formatReader["fps"];
        if (!formatReader["preference"].is_null()) format.preference = (ORIENTATION_MODE)formatReader["preference"];
        config.format = format;
    }

    if (!cameraCapturerConfigReader["followEncodeDimensionRatio"].is_null())
        config.followEncodeDimensionRatio = cameraCapturerConfigReader["followEncodeDimensionRatio"];

    MyJson outdata;
    outdata["result"] = wrapper_->startSecondaryCameraCapture(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopPrimaryCameraCapture(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopPrimaryCameraCapture();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopSecondaryCameraCapture(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopSecondaryCameraCapture();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setCameraDeviceOrientation(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VIDEO_SOURCE_TYPE type = VIDEO_SOURCE_CAMERA_PRIMARY;
    VIDEO_ORIENTATION orientation = VIDEO_ORIENTATION_0;

    if (!reader["type"].is_null()) type = reader["type"];
    if (!reader["orientation"].is_null()) orientation = reader["orientation"];

    MyJson outdata;
    outdata["result"] = wrapper_->setCameraDeviceOrientation(type, orientation);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setScreenCaptureOrientation(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VIDEO_SOURCE_TYPE type = VIDEO_SOURCE_SCREEN_PRIMARY;
    VIDEO_ORIENTATION orientation = VIDEO_ORIENTATION_0;

    if (!reader["type"].is_null()) type = reader["type"];
    if (!reader["orientation"].is_null()) orientation = reader["orientation"];

    MyJson outdata;
    outdata["result"] = wrapper_->setScreenCaptureOrientation(type, orientation);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startPrimaryScreenCapture(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    ScreenCaptureConfiguration config;

    MyJson screenCaptureConfigReader = reader["config"];

    if (!screenCaptureConfigReader["isCaptureWindow"].is_null())
        config.isCaptureWindow = screenCaptureConfigReader["isCaptureWindow"];
    if (!screenCaptureConfigReader["displayId"].is_null())
        config.displayId = screenCaptureConfigReader["displayId"];
    if (!screenCaptureConfigReader["screenRect"].is_null()) {
        MyJson screenRectReader = screenCaptureConfigReader["screenRect"];
        config.screenRect.x = screenRectReader["x"];
        config.screenRect.y = screenRectReader["y"];
        config.screenRect.width = screenRectReader["width"];
        config.screenRect.height = screenRectReader["height"];
    }
    if (!screenCaptureConfigReader["windowId"].is_null())
        config.windowId = (view_t)(long) screenCaptureConfigReader["windowId"];
    if (!screenCaptureConfigReader["params"].is_null()) {
        MyJson paramsReader = screenCaptureConfigReader["params"];
        config.params.dimensions.width = paramsReader["dimensions"]["width"];
        config.params.dimensions.height = paramsReader["dimensions"]["height"];
        config.params.frameRate = paramsReader["frameRate"];
        config.params.bitrate = paramsReader["bitrate"];
        config.params.captureMouseCursor = paramsReader["captureMouseCursor"];
    }
    if (!screenCaptureConfigReader["regionRect"].is_null()) {
        MyJson regionRectReader = screenCaptureConfigReader["regionRect"];
        config.regionRect.x = regionRectReader["x"];
        config.regionRect.y = regionRectReader["y"];
        config.regionRect.width = regionRectReader["width"];
        config.regionRect.height = regionRectReader["height"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->startPrimaryScreenCapture(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startSecondaryScreenCapture(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    ScreenCaptureConfiguration config;

    MyJson screenCaptureConfigReader = reader["config"];

    if (!screenCaptureConfigReader["isCaptureWindow"].is_null())
        config.isCaptureWindow = screenCaptureConfigReader["isCaptureWindow"];
    if (!screenCaptureConfigReader["displayId"].is_null())
        config.displayId = screenCaptureConfigReader["displayId"];
    if (!screenCaptureConfigReader["screenRect"].is_null()) {
        MyJson screenRectReader = screenCaptureConfigReader["screenRect"];
        config.screenRect.x = screenRectReader["x"];
        config.screenRect.y = screenRectReader["y"];
        config.screenRect.width = screenRectReader["width"];
        config.screenRect.height = screenRectReader["height"];
    }
    if (!screenCaptureConfigReader["windowId"].is_null())
        config.windowId = (view_t)(long) screenCaptureConfigReader["windowId"];
    if (!screenCaptureConfigReader["params"].is_null()) {
        MyJson paramsReader = screenCaptureConfigReader["params"];
        config.params.frameRate = paramsReader["frameRate"];
        config.params.bitrate = paramsReader["bitrate"];
        config.params.captureMouseCursor = paramsReader["captureMouseCursor"];
        config.params.windowFocus = paramsReader["windowFocus"];
    }
    if (!screenCaptureConfigReader["regionRect"].is_null()) {
        MyJson regionRectReader = screenCaptureConfigReader["regionRect"];
        config.regionRect.x = regionRectReader["x"];
        config.regionRect.y = regionRectReader["y"];
        config.regionRect.width = regionRectReader["width"];
        config.regionRect.height = regionRectReader["height"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->startSecondaryScreenCapture(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopPrimaryScreenCapture(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopPrimaryScreenCapture();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopSecondaryScreenCapture(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopSecondaryScreenCapture();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getConnectionState(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getConnectionState();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int registerEventHandler(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    IRtcEngineEventHandler *eventHandler = nullptr;
    if (!reader["eventHandler"].is_null()) {
        eventHandler = new IRtcEngineEventHandlerImpl();
        eventHandler->setCallback(wrapper_);
    }

    MyJson outdata;
    outdata["result"] = wrapper_->registerEventHandler(eventHandler);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setRemoteUserPriority(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    uid_t uid = (uid_t)(long) reader["uid"];
    PRIORITY_TYPE userPriority = PRIORITY_NORMAL;
    if (!reader["userPriority"].is_null()) userPriority = reader["userPriority"];

    MyJson outdata;
    outdata["result"] = wrapper_->setRemoteUserPriority(uid, userPriority);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int registerPacketObserver(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    IPacketObserver *observer = nullptr;
    if (!reader["observer"].is_null()) observer = (IPacketObserver *)(long)reader["observer"];

    MyJson outdata;
    outdata["result"] = wrapper_->registerPacketObserver(observer);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableEncryption(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    EncryptionConfig config;

    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson encryptionConfigReader = reader["config"];

    if (!encryptionConfigReader["encryptionMode"].is_null())
        config.encryptionMode = encryptionConfigReader["encryptionMode"];
    if (!encryptionConfigReader["encryptionKey"].is_null())
        config.encryptionKey = encryptionConfigReader["encryptionKey"];
    if (!encryptionConfigReader["encryptionKdfSalt"].is_null()) {
        std::string salt = encryptionConfigReader["encryptionKdfSalt"];
        memcpy(config.encryptionKdfSalt, salt.c_str(), sizeof(config.encryptionKdfSalt));
    }

    MyJson outdata;
    outdata["result"] = wrapper_->enableEncryption(enabled, config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int createDataStream(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool reliable = false;
    bool ordered = false;
    if (!reader["reliable"].is_null()) reliable = reader["reliable"];
    if (!reader["ordered"].is_null()) ordered = reader["ordered"];

    int streamId = 0;
    MyJson outdata;
    outdata["result"] = wrapper_->createDataStream(&streamId, reliable, ordered);

    outdata["streamId"] = streamId;
    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int createDataStream(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    DataStreamConfig config;
    int streamId = 0;

    MyJson dataStreamConfigReader = reader["config"];

    if (!dataStreamConfigReader["syncWithAudio"].is_null())
        config.syncWithAudio = dataStreamConfigReader["syncWithAudio"];
    if (!dataStreamConfigReader["ordered"].is_null())
        config.ordered = dataStreamConfigReader["ordered"];

    MyJson outdata;
    outdata["result"] = wrapper_->createDataStream(&streamId, config);

    MyJson result;
    result["streamId"] = streamId;
    outdata["result"] = result;

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int sendStreamMessage(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int streamId = 0;
    std::string messageData = "";
    if (!reader["streamId"].is_null()) streamId = reader["streamId"];
    if (!reader["data"].is_null()) messageData = reader["data"];

    MyJson outdata;
    outdata["result"] = wrapper_->sendStreamMessage(streamId, messageData.c_str(), messageData.length());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int addVideoWatermark(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    RtcImage watermark;
    MyJson watermarkReader = reader["watermark"];

    if (!watermarkReader["url"].is_null()) watermark.url = watermarkReader["url"];
    if (!watermarkReader["x"].is_null()) watermark.x = watermarkReader["x"];
    if (!watermarkReader["y"].is_null()) watermark.y = watermarkReader["y"];
    if (!watermarkReader["width"].is_null()) watermark.width = watermarkReader["width"];
    if (!watermarkReader["height"].is_null()) watermark.height = watermarkReader["height"];

    MyJson outdata;
    outdata["result"] = wrapper_->addVideoWatermark(watermark);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int addVideoWatermark(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    WatermarkOptions options;

    MyJson watermarkOptionsReader = reader["options"];

    if (!watermarkOptionsReader["visibleInPreview"].is_null())
        options.visibleInPreview = watermarkOptionsReader["visibleInPreview"];
    if (!watermarkOptionsReader["positionInLandscapeMode"].is_null()) {
        MyJson positionInLandscapeModeReader = watermarkOptionsReader["positionInLandscapeMode"];
        options.positionInLandscapeMode.x = positionInLandscapeModeReader["x"];
        options.positionInLandscapeMode.y = positionInLandscapeModeReader["y"];
        options.positionInLandscapeMode.width = positionInLandscapeModeReader["width"];
        options.positionInLandscapeMode.height = positionInLandscapeModeReader["height"];
    }
    if (!watermarkOptionsReader["positionInPortraitMode"].is_null()) {
        MyJson positionInPortraitModeReader = watermarkOptionsReader["positionInPortraitMode"];
        options.positionInPortraitMode.x = positionInPortraitModeReader["x"];
        options.positionInPortraitMode.y = positionInPortraitModeReader["y"];
        options.positionInPortraitMode.width = positionInPortraitModeReader["width"];
        options.positionInPortraitMode.height = positionInPortraitModeReader["height"];
    }
    if (!watermarkOptionsReader["watermarkRatio"].is_null())
        options.watermarkRatio = watermarkOptionsReader["watermarkRatio"];
    if (!watermarkOptionsReader["mode"].is_null())
        options.mode = watermarkOptionsReader["mode"];

    string watermarkUrl = "";
    if (!reader["watermarkUrl"].is_null()) watermarkUrl = reader["watermarkUrl"];

    MyJson outdata;
    outdata["result"] = wrapper_->addVideoWatermark(
        watermarkUrl.empty() ? nullptr : watermarkUrl.c_str(), options);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int clearVideoWatermarks(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->clearVideoWatermarks();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int sendCustomReportMessage(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string id = "";
    string category = "";
    string event = "";
    string label = "";
    int value = 0;
    if (!reader["id"].is_null()) id = reader["id"];
    if (!reader["category"].is_null()) category = reader["category"];
    if (!reader["event"].is_null()) event = reader["event"];
    if (!reader["label"].is_null()) label = reader["label"];
    if (!reader["value"].is_null()) value = reader["value"];

    MyJson outdata;
    outdata["result"] = wrapper_->sendCustomReportMessage(
        id.empty() ? nullptr : id.c_str(), category.empty() ? nullptr : category.c_str(),
        event.empty() ? nullptr : event.c_str(), label.empty() ? nullptr : label.c_str(), value);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int registerMediaMetadataObserver(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    IMetadataObserver *observer = nullptr;
    IMetadataObserver::METADATA_TYPE type = IMetadataObserver::METADATA_TYPE::UNKNOWN_METADATA;
    if (!reader["observer"].is_null()) observer = (IMetadataObserver *)(long) reader["observer"];
    if (!reader["type"].is_null()) type = (IMetadataObserver::METADATA_TYPE)(int) reader["type"];

    MyJson outdata;
    outdata["result"] = wrapper_->registerMediaMetadataObserver(observer, type);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int unregisterMediaMetadataObserver(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    IMetadataObserver *observer = nullptr;
    IMetadataObserver::METADATA_TYPE type = IMetadataObserver::METADATA_TYPE::UNKNOWN_METADATA;
    if (!reader["observer"].is_null()) observer = (IMetadataObserver *)(long)reader["observer"];
    if (!reader["type"].is_null()) type = (IMetadataObserver::METADATA_TYPE)(int)reader["type"];

    MyJson outdata;
    outdata["result"] = wrapper_->unregisterMediaMetadataObserver(observer, type);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startAudioFrameDump(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string channel_id = "";
    uid_t user_id;
    string location = "";
    string uuid = "";
    string passwd = "";
    long duration_ms = 0;
    bool auto_upload = false;

    if (!reader["channel_id"].is_null()) channel_id = reader["channel_id"];
    if (!reader["user_id"].is_null()) user_id = (uid_t)(long) reader["user_id"];
    if (!reader["location"].is_null()) location = reader["location"];
    if (!reader["uuid"].is_null()) uuid = reader["uuid"];
    if (!reader["passwd"].is_null()) passwd = reader["passwd"];
    if (!reader["duration_ms"].is_null()) duration_ms = reader["duration_ms"];
    if (!reader["auto_upload"].is_null()) auto_upload = reader["auto_upload"];

    MyJson outdata;
    outdata["result"] = wrapper_->startAudioFrameDump(
        channel_id.empty() ? nullptr : channel_id.c_str(), user_id,
        location.empty() ? nullptr : location.c_str(),
        uuid.empty() ? nullptr : uuid.c_str(),
        passwd.empty() ? nullptr : passwd.c_str(), duration_ms, auto_upload);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopAudioFrameDump(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string channel_id = "";
    uid_t user_id;
    string location = "";
    if (!reader["channel_id"].is_null()) channel_id = reader["channel_id"];
    if (!reader["user_id"].is_null()) user_id = (uid_t)(long) reader["user_id"];
    if (!reader["location"].is_null()) location = reader["location"];

    MyJson outdata;
    outdata["result"] = wrapper_->stopAudioFrameDump(
        channel_id.empty() ? nullptr : channel_id.c_str(), user_id,
        location.empty() ? nullptr : location.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int registerLocalUserAccount(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string appId = "";
    string userAccount = "";
    if (!reader["appId"].is_null()) appId = reader["appId"];
    if (!reader["userAccount"].is_null()) userAccount = reader["userAccount"];

    MyJson outdata;
    outdata["result"] = wrapper_->registerLocalUserAccount(
        appId.empty() ? nullptr : appId.c_str(),
        userAccount.empty() ? nullptr : userAccount.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int joinChannelWithUserAccount(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string token = "";
    string channelId = "";
    string userAccount = "";
    if (!reader["token"].is_null()) token = reader["token"];
    if (!reader["channelId"].is_null()) channelId = reader["channelId"];
    if (!reader["userAccount"].is_null()) userAccount = reader["userAccount"];

    MyJson outdata;
    outdata["result"] = wrapper_->joinChannelWithUserAccount(
        token.empty() ? nullptr : token.c_str(), channelId.c_str(),
        userAccount.empty() ? nullptr : userAccount.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int joinChannelWithUserAccount(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string token = "";
    string channelId = "";
    string userAccount = "";
    ChannelMediaOptions options;

    if (!reader["token"].is_null()) token = reader["token"];
    if (!reader["channelId"].is_null()) channelId = reader["channelId"];
    if (!reader["userAccount"].is_null()) userAccount = reader["userAccount"];

    MyJson channelMediaOptionsReader = reader["options"];

    if (!channelMediaOptionsReader["publishCameraTrack"].is_null())
        options.publishCameraTrack = channelMediaOptionsReader["publishCameraTrack"];
    if (!channelMediaOptionsReader["publishSecondaryCameraTrack"].is_null())
        options.publishSecondaryCameraTrack = channelMediaOptionsReader["publishSecondaryCameraTrack"];
    if (!channelMediaOptionsReader["publishMicrophoneTrack"].is_null())
        options.publishMicrophoneTrack = channelMediaOptionsReader["publishMicrophoneTrack"];
    #if defined(__ANDROID__) || (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE)
    if (!channelMediaOptionsReader["publishScreenCaptureVideo"].is_null())
        options.publishScreenCaptureVideo = channelMediaOptionsReader["publishScreenCaptureVideo"];
    if (!channelMediaOptionsReader["publishScreenCaptureAudio"].is_null())
        options.publishScreenCaptureAudio = channelMediaOptionsReader["publishScreenCaptureAudio"];
    #else
    if (!channelMediaOptionsReader["publishScreenTrack"].is_null())
        options.publishScreenTrack = channelMediaOptionsReader["publishScreenTrack"];
    if (!channelMediaOptionsReader["publishSecondaryScreenTrack"].is_null())
        options.publishSecondaryScreenTrack = channelMediaOptionsReader["publishSecondaryScreenTrack"];
    #endif
    if (!channelMediaOptionsReader["publishCustomAudioTrack"].is_null())
        options.publishCustomAudioTrack = channelMediaOptionsReader["publishCustomAudioTrack"];
    if (!channelMediaOptionsReader["publishCustomAudioSourceId"].is_null())
        options.publishCustomAudioSourceId = channelMediaOptionsReader["publishCustomAudioSourceId"];
    if (!channelMediaOptionsReader["publishCustomAudioTrackEnableAec"].is_null())
        options.publishCustomAudioTrackEnableAec = channelMediaOptionsReader["publishCustomAudioTrackEnableAec"];
    if (!channelMediaOptionsReader["publishDirectCustomAudioTrack"].is_null())
        options.publishDirectCustomAudioTrack = channelMediaOptionsReader["publishDirectCustomAudioTrack"];
    if (!channelMediaOptionsReader["publishCustomAudioTrackAec"].is_null())
        options.publishCustomAudioTrackAec = channelMediaOptionsReader["publishCustomAudioTrackAec"];
    if (!channelMediaOptionsReader["publishCustomVideoTrack"].is_null())
        options.publishCustomVideoTrack = channelMediaOptionsReader["publishCustomVideoTrack"];
    if (!channelMediaOptionsReader["publishEncodedVideoTrack"].is_null())
        options.publishEncodedVideoTrack = channelMediaOptionsReader["publishEncodedVideoTrack"];
    if (!channelMediaOptionsReader["publishMediaPlayerAudioTrack"].is_null())
        options.publishMediaPlayerAudioTrack = channelMediaOptionsReader["publishMediaPlayerAudioTrack"];
    if (!channelMediaOptionsReader["publishMediaPlayerVideoTrack"].is_null())
        options.publishMediaPlayerVideoTrack = channelMediaOptionsReader["publishMediaPlayerVideoTrack"];
    if (!channelMediaOptionsReader["publishTrancodedVideoTrack"].is_null())
        options.publishTrancodedVideoTrack = channelMediaOptionsReader["publishTrancodedVideoTrack"];
    if (!channelMediaOptionsReader["autoSubscribeAudio"].is_null())
        options.autoSubscribeAudio = channelMediaOptionsReader["autoSubscribeAudio"];
    if (!channelMediaOptionsReader["autoSubscribeVideo"].is_null())
        options.autoSubscribeVideo = channelMediaOptionsReader["autoSubscribeVideo"];
    if (!channelMediaOptionsReader["enableAudioRecordingOrPlayout"].is_null())
        options.enableAudioRecordingOrPlayout = channelMediaOptionsReader["enableAudioRecordingOrPlayout"];
    if (!channelMediaOptionsReader["publishMediaPlayerId"].is_null())
        options.publishMediaPlayerId = channelMediaOptionsReader["publishMediaPlayerId"];
    if (!channelMediaOptionsReader["clientRoleType"].is_null())
        options.clientRoleType = channelMediaOptionsReader["clientRoleType"];
    if (!channelMediaOptionsReader["audienceLatencyLevel"].is_null())
        options.audienceLatencyLevel = channelMediaOptionsReader["audienceLatencyLevel"];
    if (!channelMediaOptionsReader["defaultVideoStreamType"].is_null())
        options.defaultVideoStreamType = channelMediaOptionsReader["defaultVideoStreamType"];
    if (!channelMediaOptionsReader["channelProfile"].is_null())
        options.channelProfile = channelMediaOptionsReader["channelProfile"];
    if (!channelMediaOptionsReader["audioDelayMs"].is_null())
        options.audioDelayMs = channelMediaOptionsReader["audioDelayMs"];
    if (!channelMediaOptionsReader["mediaPlayerAudioDelayMs"].is_null())
        options.mediaPlayerAudioDelayMs = channelMediaOptionsReader["mediaPlayerAudioDelayMs"];
    if (!channelMediaOptionsReader["token"].is_null())
        options.token = channelMediaOptionsReader["token"];
    if (!channelMediaOptionsReader["enableBuiltInMediaEncryption"].is_null())
        options.enableBuiltInMediaEncryption = channelMediaOptionsReader["enableBuiltInMediaEncryption"];
    if (!channelMediaOptionsReader["publishRhythmPlayerTrack"].is_null())
        options.publishRhythmPlayerTrack = channelMediaOptionsReader["publishRhythmPlayerTrack"];
    if (!channelMediaOptionsReader["isInteractiveAudience"].is_null())
        options.isInteractiveAudience = channelMediaOptionsReader["isInteractiveAudience"];
    if (!channelMediaOptionsReader["customVideoTrackId"].is_null())
        options.customVideoTrackId = channelMediaOptionsReader["customVideoTrackId"];
    if (!channelMediaOptionsReader["isAudioFilterable"].is_null())
        options.isAudioFilterable = channelMediaOptionsReader["isAudioFilterable"];

    MyJson outdata;
    outdata["result"] = wrapper_->joinChannelWithUserAccount(
        token.empty() ? nullptr : token.c_str(), channelId.c_str(),
        userAccount.empty() ? nullptr : userAccount.c_str(), options);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int joinChannelWithUserAccountEx(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string token = "";
    string channelId = "";
    string userAccount = "";
    ChannelMediaOptions options;

    if (!reader["token"].is_null()) token = reader["token"];
    if (!reader["channelId"].is_null()) channelId = reader["channelId"];
    if (!reader["userAccount"].is_null()) userAccount = reader["userAccount"];

    MyJson channelMediaOptionsReader = reader["options"];

    if (!channelMediaOptionsReader["publishCameraTrack"].is_null())
        options.publishCameraTrack = channelMediaOptionsReader["publishCameraTrack"];
    if (!channelMediaOptionsReader["publishSecondaryCameraTrack"].is_null())
        options.publishSecondaryCameraTrack = channelMediaOptionsReader["publishSecondaryCameraTrack"];
    if (!channelMediaOptionsReader["publishMicrophoneTrack"].is_null())
        options.publishMicrophoneTrack = channelMediaOptionsReader["publishMicrophoneTrack"];
    #if defined(__ANDROID__) || (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE)
    if (!channelMediaOptionsReader["publishScreenCaptureVideo"].is_null())
        options.publishScreenCaptureVideo = channelMediaOptionsReader["publishScreenCaptureVideo"];
    if (!channelMediaOptionsReader["publishScreenCaptureAudio"].is_null())
        options.publishScreenCaptureAudio = channelMediaOptionsReader["publishScreenCaptureAudio"];
    #else
    if (!channelMediaOptionsReader["publishScreenTrack"].is_null())
        options.publishScreenTrack = channelMediaOptionsReader["publishScreenTrack"];
    if (!channelMediaOptionsReader["publishSecondaryScreenTrack"].is_null())
        options.publishSecondaryScreenTrack = channelMediaOptionsReader["publishSecondaryScreenTrack"];
    #endif
    if (!channelMediaOptionsReader["publishCustomAudioTrack"].is_null())
        options.publishCustomAudioTrack = channelMediaOptionsReader["publishCustomAudioTrack"];
    if (!channelMediaOptionsReader["publishCustomAudioSourceId"].is_null())
        options.publishCustomAudioSourceId = channelMediaOptionsReader["publishCustomAudioSourceId"];
    if (!channelMediaOptionsReader["publishCustomAudioTrackEnableAec"].is_null())
        options.publishCustomAudioTrackEnableAec = channelMediaOptionsReader["publishCustomAudioTrackEnableAec"];
    if (!channelMediaOptionsReader["publishDirectCustomAudioTrack"].is_null())
        options.publishDirectCustomAudioTrack = channelMediaOptionsReader["publishDirectCustomAudioTrack"];
    if (!channelMediaOptionsReader["publishCustomAudioTrackAec"].is_null())
        options.publishCustomAudioTrackAec = channelMediaOptionsReader["publishCustomAudioTrackAec"];
    if (!channelMediaOptionsReader["publishCustomVideoTrack"].is_null())
        options.publishCustomVideoTrack = channelMediaOptionsReader["publishCustomVideoTrack"];
    if (!channelMediaOptionsReader["publishEncodedVideoTrack"].is_null())
        options.publishEncodedVideoTrack = channelMediaOptionsReader["publishEncodedVideoTrack"];
    if (!channelMediaOptionsReader["publishMediaPlayerAudioTrack"].is_null())
        options.publishMediaPlayerAudioTrack = channelMediaOptionsReader["publishMediaPlayerAudioTrack"];
    if (!channelMediaOptionsReader["publishMediaPlayerVideoTrack"].is_null())
        options.publishMediaPlayerVideoTrack = channelMediaOptionsReader["publishMediaPlayerVideoTrack"];
    if (!channelMediaOptionsReader["publishTrancodedVideoTrack"].is_null())
        options.publishTrancodedVideoTrack = channelMediaOptionsReader["publishTrancodedVideoTrack"];
    if (!channelMediaOptionsReader["autoSubscribeAudio"].is_null())
        options.autoSubscribeAudio = channelMediaOptionsReader["autoSubscribeAudio"];
    if (!channelMediaOptionsReader["autoSubscribeVideo"].is_null())
        options.autoSubscribeVideo = channelMediaOptionsReader["autoSubscribeVideo"];
    if (!channelMediaOptionsReader["enableAudioRecordingOrPlayout"].is_null())
        options.enableAudioRecordingOrPlayout = channelMediaOptionsReader["enableAudioRecordingOrPlayout"];
    if (!channelMediaOptionsReader["publishMediaPlayerId"].is_null())
        options.publishMediaPlayerId = channelMediaOptionsReader["publishMediaPlayerId"];
    if (!channelMediaOptionsReader["clientRoleType"].is_null())
        options.clientRoleType = channelMediaOptionsReader["clientRoleType"];
    if (!channelMediaOptionsReader["audienceLatencyLevel"].is_null())
        options.audienceLatencyLevel = channelMediaOptionsReader["audienceLatencyLevel"];
    if (!channelMediaOptionsReader["defaultVideoStreamType"].is_null())
        options.defaultVideoStreamType = channelMediaOptionsReader["defaultVideoStreamType"];
    if (!channelMediaOptionsReader["channelProfile"].is_null())
        options.channelProfile = channelMediaOptionsReader["channelProfile"];
    if (!channelMediaOptionsReader["audioDelayMs"].is_null())
        options.audioDelayMs = channelMediaOptionsReader["audioDelayMs"];
    if (!channelMediaOptionsReader["mediaPlayerAudioDelayMs"].is_null())
        options.mediaPlayerAudioDelayMs = channelMediaOptionsReader["mediaPlayerAudioDelayMs"];
    if (!channelMediaOptionsReader["enableBuiltInMediaEncryption"].is_null())
        options.enableBuiltInMediaEncryption = channelMediaOptionsReader["enableBuiltInMediaEncryption"];
    if (!channelMediaOptionsReader["publishRhythmPlayerTrack"].is_null())
        options.publishRhythmPlayerTrack = channelMediaOptionsReader["publishRhythmPlayerTrack"];
    if (!channelMediaOptionsReader["isInteractiveAudience"].is_null())
        options.isInteractiveAudience = channelMediaOptionsReader["isInteractiveAudience"];
    if (!channelMediaOptionsReader["customVideoTrackId"].is_null())
        options.customVideoTrackId = channelMediaOptionsReader["customVideoTrackId"];
    if (!channelMediaOptionsReader["isAudioFilterable"].is_null())
        options.isAudioFilterable = channelMediaOptionsReader["isAudioFilterable"];

    MyJson outdata;
    outdata["result"] = wrapper_->joinChannelWithUserAccountEx(
        token.empty() ? nullptr : token.c_str(), channelId.c_str(),
        userAccount.empty() ? nullptr : userAccount.c_str(), options,
        eventHandler_);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getUserInfoByUserAccount(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string userAccount = "";
    if (!reader["userAccount"].is_null()) userAccount = reader["userAccount"];

    rtc::UserInfo userInfo;
    MyJson outdata;
    outdata["result"] = wrapper_->getUserInfoByUserAccount(userAccount.c_str(), &userInfo);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getUserInfoByUid(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    uid_t uid = (uid_t)(long) reader["uid"];
    rtc::UserInfo userInfo;

    MyJson outdata;
    outdata["result"] = wrapper_->getUserInfoByUid(uid, &userInfo);

    MyJson userInfoJson;
    userInfoJson["userId"] = userInfo.userId;
    userInfoJson["userAccount"] = userInfo.userAccount;
    userInfoJson["userName"] = userInfo.userName;
    userInfoJson["userInfo"] = userInfo.userInfo;
    outdata["userInfo"] = userInfoJson;

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startChannelMediaRelay(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    ChannelMediaRelayConfiguration configuration;
    configuration.srcInfo = nullptr;
    configuration.destInfos = nullptr;
    configuration.destCount = 0;

    MyJson srcInfoReader = reader["srcInfo"];
    if (!srcInfoReader.is_null()) {
        configuration.srcInfo = new ChannelMediaInfo();
        if (!srcInfoReader["channelName"].is_null())
            configuration.srcInfo->channelName = srcInfoReader["channelName"];
        if (!srcInfoReader["uid"].is_null())
            configuration.srcInfo->uid = (uid_t)(long) srcInfoReader["uid"];
        if (!srcInfoReader["token"].is_null())
            configuration.srcInfo->token = srcInfoReader["token"];
    }

    MyJson destInfosReader = reader["destInfos"];
    if (!destInfosReader.is_null()) {
        configuration.destCount = destInfosReader.size();
        configuration.destInfos = new ChannelMediaInfo[configuration.destCount];
        for (int i = 0; i < configuration.destCount; i++) {
            MyJson destInfoReader = destInfosReader[i];
            if (!destInfoReader["channelName"].is_null())
                configuration.destInfos[i].channelName = destInfoReader["channelName"];
            if (!destInfoReader["uid"].is_null())
                configuration.destInfos[i].uid = (uid_t)(long) destInfoReader["uid"];
            if (!destInfoReader["token"].is_null())
                configuration.destInfos[i].token = destInfoReader["token"];
        }
    }

    MyJson outdata;
    outdata["result"] = wrapper_->startChannelMediaRelay(configuration);

    if (configuration.srcInfo) delete configuration.srcInfo;
    if (configuration.destInfos) delete[] configuration.destInfos;

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int updateChannelMediaRelay(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    ChannelMediaRelayConfiguration configuration;
    configuration.srcInfo = nullptr;
    configuration.destInfos = nullptr;
    configuration.destCount = 0;

    MyJson srcInfoReader = reader["srcInfo"];
    if (!srcInfoReader.is_null()) {
        configuration.srcInfo = new ChannelMediaInfo();
        if (!srcInfoReader["channelName"].is_null())
            configuration.srcInfo->channelName = srcInfoReader["channelName"];
        if (!srcInfoReader["uid"].is_null())
            configuration.srcInfo->uid = (uid_t)(long) srcInfoReader["uid"];
        if (!srcInfoReader["token"].is_null())
            configuration.srcInfo->token = srcInfoReader["token"];
    }

    MyJson destInfosReader = reader["destInfos"];
    if (!destInfosReader.is_null()) {
        configuration.destCount = destInfosReader.size();
        configuration.destInfos = new ChannelMediaInfo[configuration.destCount];
        for (int i = 0; i < configuration.destCount; i++) {
            MyJson destInfoReader = destInfosReader[i];
            if (!destInfoReader["channelName"].is_null())
                configuration.destInfos[i].channelName = destInfoReader["channelName"];
            if (!destInfoReader["uid"].is_null())
                configuration.destInfos[i].uid = (uid_t)(long) destInfoReader["uid"];
            if (!destInfoReader["token"].is_null())
                configuration.destInfos[i].token = destInfoReader["token"];
        }
    }

    MyJson outdata;
    outdata["result"] = wrapper_->updateChannelMediaRelay(configuration);

    if (configuration.srcInfo) delete configuration.srcInfo;
    if (configuration.destInfos) delete[] configuration.destInfos;

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopChannelMediaRelay(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopChannelMediaRelay();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int pauseAllChannelMediaRelay(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->pauseAllChannelMediaRelay();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int resumeAllChannelMediaRelay(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->resumeAllChannelMediaRelay();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setDirectCdnStreamingAudioConfiguration(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AUDIO_PROFILE_TYPE profile = AUDIO_PROFILE_DEFAULT;
    if (!reader["profile"].is_null()) profile = reader["profile"];

    MyJson outdata;
    outdata["result"] = wrapper_->setDirectCdnStreamingAudioConfiguration(profile);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setDirectCdnStreamingVideoConfiguration(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    VideoEncoderConfiguration config;

    MyJson videoEncoderConfigReader = reader["config"];

    if (!videoEncoderConfigReader["codecType"].is_null())
        config.codecType = videoEncoderConfigReader["codecType"];
    if (!videoEncoderConfigReader["dimensions"].is_null()) {
        MyJson dimensionsReader = videoEncoderConfigReader["dimensions"];
        config.dimensions.width = dimensionsReader["width"];
        config.dimensions.height = dimensionsReader["height"];
    }
    if (!videoEncoderConfigReader["frameRate"].is_null())
        config.frameRate = videoEncoderConfigReader["frameRate"];
    if (!videoEncoderConfigReader["bitrate"].is_null())
        config.bitrate = videoEncoderConfigReader["bitrate"];
    if (!videoEncoderConfigReader["minBitrate"].is_null())
        config.minBitrate = videoEncoderConfigReader["minBitrate"];
    if (!videoEncoderConfigReader["orientationMode"].is_null())
        config.orientationMode = videoEncoderConfigReader["orientationMode"];
    if (!videoEncoderConfigReader["degradationPreference"].is_null())
        config.degradationPreference = videoEncoderConfigReader["degradationPreference"];
    if (!videoEncoderConfigReader["mirrorMode"].is_null())
        config.mirrorMode = videoEncoderConfigReader["mirrorMode"];
    if (!videoEncoderConfigReader["advanceOptions"].is_null()) {
        MyJson advanceOptionsReader = videoEncoderConfigReader["advanceOptions"];
        if (!advanceOptionsReader["channelName"].is_null())
            config.advanceOptions.channelName = advanceOptionsReader["channelName"];
        if (!advanceOptionsReader["streamName"].is_null())
            config.advanceOptions.streamName = advanceOptionsReader["streamName"];
        if (!advanceOptionsReader["publishUrl"].is_null())
            config.advanceOptions.publishUrl = advanceOptionsReader["publishUrl"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->setDirectCdnStreamingVideoConfiguration(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startDirectCdnStreaming(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    IDirectCdnStreamingEventHandler *eventHandler = nullptr;
    string publishUrl = "";
    DirectCdnStreamingMediaOptions options;

    if (!reader["eventHandler"].is_null()) eventHandler = (IDirectCdnStreamingEventHandler *)(long) reader["eventHandler"];
    if (!reader["publishUrl"].is_null()) publishUrl = reader["publishUrl"];

    MyJson directCdnStreamingMediaOptionsReader = reader["options"];

    if (!directCdnStreamingMediaOptionsReader["publishCameraTrack"].is_null())
        options.publishCameraTrack = directCdnStreamingMediaOptionsReader["publishCameraTrack"];
    if (!directCdnStreamingMediaOptionsReader["publishMicrophoneTrack"].is_null())
        options.publishMicrophoneTrack = directCdnStreamingMediaOptionsReader["publishMicrophoneTrack"];
    if (!directCdnStreamingMediaOptionsReader["publishCustomAudioTrack"].is_null())
        options.publishCustomAudioTrack = directCdnStreamingMediaOptionsReader["publishCustomAudioTrack"];
    if (!directCdnStreamingMediaOptionsReader["publishCustomVideoTrack"].is_null())
        options.publishCustomVideoTrack = directCdnStreamingMediaOptionsReader["publishCustomVideoTrack"];
    if (!directCdnStreamingMediaOptionsReader["publishMediaPlayerAudioTrack"].is_null())
        options.publishMediaPlayerAudioTrack = directCdnStreamingMediaOptionsReader["publishMediaPlayerAudioTrack"];
    if (!directCdnStreamingMediaOptionsReader["publishMediaPlayerId"].is_null())
        options.publishMediaPlayerId = directCdnStreamingMediaOptionsReader["publishMediaPlayerId"];
    if (!directCdnStreamingMediaOptionsReader["customVideoTrackId"].is_null())
        options.customVideoTrackId = (video_track_id_t)(long) directCdnStreamingMediaOptionsReader["customVideoTrackId"];

    MyJson outdata;
    outdata["result"] = wrapper_->startDirectCdnStreaming(eventHandler, publishUrl.c_str(), options);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopDirectCdnStreaming(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopDirectCdnStreaming();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int updateDirectCdnStreamingMediaOptions(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    DirectCdnStreamingMediaOptions options;

    MyJson directCdnStreamingMediaOptionsReader = reader["options"];

    if (!directCdnStreamingMediaOptionsReader["publishCameraTrack"].is_null())
        options.publishCameraTrack = directCdnStreamingMediaOptionsReader["publishCameraTrack"];
    if (!directCdnStreamingMediaOptionsReader["publishMicrophoneTrack"].is_null())
        options.publishMicrophoneTrack = directCdnStreamingMediaOptionsReader["publishMicrophoneTrack"];
    if (!directCdnStreamingMediaOptionsReader["publishCustomAudioTrack"].is_null())
        options.publishCustomAudioTrack = directCdnStreamingMediaOptionsReader["publishCustomAudioTrack"];
    if (!directCdnStreamingMediaOptionsReader["publishCustomVideoTrack"].is_null())
        options.publishCustomVideoTrack = directCdnStreamingMediaOptionsReader["publishCustomVideoTrack"];
    if (!directCdnStreamingMediaOptionsReader["publishMediaPlayerAudioTrack"].is_null())
        options.publishMediaPlayerAudioTrack = directCdnStreamingMediaOptionsReader["publishMediaPlayerAudioTrack"];
    if (!directCdnStreamingMediaOptionsReader["publishMediaPlayerId"].is_null())
        options.publishMediaPlayerId = directCdnStreamingMediaOptionsReader["publishMediaPlayerId"];
    if (!directCdnStreamingMediaOptionsReader["customVideoTrackId"].is_null())
        options.customVideoTrackId = (video_track_id_t)(long) directCdnStreamingMediaOptionsReader["customVideoTrackId"];

    MyJson outdata;
    outdata["result"] = wrapper_->updateDirectCdnStreamingMediaOptions(options);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startRhythmPlayer(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AgoraRhythmPlayerConfig config;
    MyJson rhythmPlayerConfigReader = reader["config"];

    if (!rhythmPlayerConfigReader["beatsPerMeasure"].is_null())
        config.beatsPerMeasure = rhythmPlayerConfigReader["beatsPerMeasure"];
    if (!rhythmPlayerConfigReader["beatsPerMinute"].is_null())
        config.beatsPerMinute = rhythmPlayerConfigReader["beatsPerMinute"];

    string sound1 = "";
    string sound2 = "";
    if (!reader["sound1"].is_null()) sound1 = reader["sound1"];
    if (!reader["sound2"].is_null()) sound2 = reader["sound2"];

    MyJson outdata;
    outdata["result"] = wrapper_->startRhythmPlayer(
        sound1.empty() ? nullptr : sound1.c_str(),
        sound2.empty() ? nullptr : sound2.c_str(), config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int stopRhythmPlayer(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->stopRhythmPlayer();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int configRhythmPlayer(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AgoraRhythmPlayerConfig config;

    MyJson rhythmPlayerConfigReader = reader["config"];

    if (!rhythmPlayerConfigReader["beatsPerMeasure"].is_null())
        config.beatsPerMeasure = rhythmPlayerConfigReader["beatsPerMeasure"];
    if (!rhythmPlayerConfigReader["beatsPerMinute"].is_null())
        config.beatsPerMinute = rhythmPlayerConfigReader["beatsPerMinute"];

    MyJson outdata;
    outdata["result"] = wrapper_->configRhythmPlayer(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableContentInspect(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    media::ContentInspectConfig config;

    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson contentInspectConfigReader = reader["config"];

    if (!contentInspectConfigReader["enableAudioInspect"].is_null())
        config.enableAudioInspect = contentInspectConfigReader["enableAudioInspect"];
    if (!contentInspectConfigReader["enableVideoInspect"].is_null())
        config.enableVideoInspect = contentInspectConfigReader["enableVideoInspect"];
    if (!contentInspectConfigReader["audioInspectInterval"].is_null())
        config.audioInspectInterval = contentInspectConfigReader["audioInspectInterval"];
    if (!contentInspectConfigReader["videoInspectInterval"].is_null())
        config.videoInspectInterval = contentInspectConfigReader["videoInspectInterval"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableContentInspect(enabled, config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int adjustCustomAudioPublishVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int32_t sourceId = 0;
    int volume = 0;
    if (!reader["sourceId"].is_null()) sourceId = reader["sourceId"];
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->adjustCustomAudioPublishVolume(sourceId, volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int adjustCustomAudioPlayoutVolume(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    int32_t sourceId = 0;
    int volume = 0;
    if (!reader["sourceId"].is_null()) sourceId = reader["sourceId"];
    if (!reader["volume"].is_null()) volume = reader["volume"];

    MyJson outdata;
    outdata["result"] = wrapper_->adjustCustomAudioPlayoutVolume(sourceId, volume);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setCloudProxy(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    CLOUD_PROXY_TYPE proxyType = NONE_PROXY;
    if (!reader["proxyType"].is_null()) proxyType = reader["proxyType"];

    MyJson outdata;
    outdata["result"] = wrapper_->setCloudProxy(proxyType);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setLocalAccessPoint(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    LocalAccessPointConfiguration config;

    MyJson localAccessPointConfigReader = reader["config"];

    if (!localAccessPointConfigReader["ipList"].is_null()) {
        MyJson ipListReader = localAccessPointConfigReader["ipList"];
        config.ipListSize = ipListReader.size();
        config.ipList = new const char*[config.ipListSize];
        for (int i = 0; i < config.ipListSize; i++) {
            config.ipList[i] = ipListReader[i];
        }
    }

    if (!localAccessPointConfigReader["domainList"].is_null()) {
        MyJson domainListReader = localAccessPointConfigReader["domainList"];
        config.domainListSize = domainListReader.size();
        config.domainList = new const char*[config.domainListSize];
        for (int i = 0; i < config.domainListSize; i++) {
            config.domainList[i] = domainListReader[i];
        }
    }

    if (!localAccessPointConfigReader["verifyDomainName"].is_null())
        config.verifyDomainName = localAccessPointConfigReader["verifyDomainName"];

    if (!localAccessPointConfigReader["mode"].is_null())
        config.mode = localAccessPointConfigReader["mode"];

    if (!localAccessPointConfigReader["advancedConfig"].is_null()) {
        MyJson advancedConfigReader = localAccessPointConfigReader["advancedConfig"];
        config.advancedConfig = AdvancedConfigInfo();
        if (!advancedConfigReader["proxyType"].is_null())
            config.advancedConfig.proxyType = advancedConfigReader["proxyType"];
        if (!advancedConfigReader["proxyAddr"].is_null())
            config.advancedConfig.proxyAddr = advancedConfigReader["proxyAddr"];
        if (!advancedConfigReader["proxyPort"].is_null())
            config.advancedConfig.proxyPort = advancedConfigReader["proxyPort"];
        if (!advancedConfigReader["proxyUsername"].is_null())
            config.advancedConfig.proxyUsername = advancedConfigReader["proxyUsername"];
        if (!advancedConfigReader["proxyPassword"].is_null())
            config.advancedConfig.proxyPassword = advancedConfigReader["proxyPassword"];
    }

    MyJson outdata;
    outdata["result"] = wrapper_->setLocalAccessPoint(config);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setAdvancedAudioOptions(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    AdvancedAudioOptions options;
    if (!reader["audioProcessingChannels"].is_null())
        options.audioProcessingChannels = reader["audioProcessingChannels"];

    int sourceType = 0;
    if (!reader["sourceType"].is_null()) sourceType = reader["sourceType"];

    MyJson outdata;
    outdata["result"] = wrapper_->setAdvancedAudioOptions(options, sourceType);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setAVSyncSource(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string channelId = "";
    uid_t uid;
    if (!reader["channelId"].is_null()) channelId = reader["channelId"];
    if (!reader["uid"].is_null()) uid = (uid_t)(long) reader["uid"];

    MyJson outdata;
    outdata["result"] = wrapper_->setAVSyncSource(channelId.c_str(), uid);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableVideoImageSource(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enable = false;
    ImageTrackOptions options;

    if (!reader["enable"].is_null()) enable = reader["enable"];

    MyJson imageTrackOptionsReader = reader["options"];

    if (!imageTrackOptionsReader["imageUrl"].is_null())
        options.imageUrl = imageTrackOptionsReader["imageUrl"];
    if (!imageTrackOptionsReader["fps"].is_null())
        options.fps = imageTrackOptionsReader["fps"];
    if (!imageTrackOptionsReader["mirrorMode"].is_null())
        options.mirrorMode = imageTrackOptionsReader["mirrorMode"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableVideoImageSource(enable, options);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getCurrentMonotonicTimeInMs(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getCurrentMonotonicTimeInMs();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableWirelessAccelerate(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    bool enabled = false;
    if (!reader["enabled"].is_null()) enabled = reader["enabled"];

    MyJson outdata;
    outdata["result"] = wrapper_->enableWirelessAccelerate(enabled);

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int getNetworkType(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->getNetworkType();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int setParameters(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    std::string data(buff, bufflen);
    MyJson reader = JSON_PARSE(data);

    string parameters = "";
    if (!reader["parameters"].is_null()) parameters = reader["parameters"];

    MyJson outdata;
    outdata["result"] = wrapper_->setParameters(parameters.c_str());

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int startMediaRenderingTracing(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->startMediaRenderingTracing();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}

int enableInstantMediaRendering(const char *buff, size_t bufflen, std::string &out) {
    TRY_CATCH_START
    MyJson outdata;
    outdata["result"] = wrapper_->enableInstantMediaRendering();

    out = JSON_TO_STRING(outdata);
    TRY_CATCH_END
    return 0;
}
};